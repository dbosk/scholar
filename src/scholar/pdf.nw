\chapter{PDF Management}
\label{pdf-module}

\section{Introduction}

When reviewing papers, researchers often need to view the full PDF, especially
when the abstract is missing or insufficient. This module provides PDF
download and caching functionality that can be used both programmatically
and through the TUI.

\subsection{Design Goals}

The PDF management module is designed with these goals:
\begin{description}
\item[Separation from TUI] PDF functionality should be usable from Python
  code without any TUI dependencies, enabling automation and scripting.
\item[Content-addressed caching] PDFs are cached by URL hash, providing
  automatic deduplication across searches.
\item[Graceful error handling] Download failures are reported clearly
  with actionable error messages.
\item[Platform independence] Works on Linux, macOS, and Windows.
\end{description}

\subsection{Why a Separate PDF Cache?}

PDFs are cached separately from search results for several reasons:
\begin{description}
\item[Size] PDFs are typically megabytes, while search metadata is kilobytes.
  Mixing them would bloat the search cache and slow down cache operations.
\item[Lifecycle] Search caches may be cleared to refresh results, but
  downloaded PDFs should persist---re-downloading is slow and wastes bandwidth.
\item[Sharing] The same PDF may appear in multiple searches. A content-addressed
  cache (keyed by URL hash) naturally deduplicates across sessions.
\end{description}

\section{Module Structure}

<<[[pdf.py]]>>=
"""
PDF download and caching for academic papers.

Provides functions to download, cache, and open PDFs from paper URLs.
The cache is content-addressed using SHA-256 hashes of URLs.
"""
<<pdf imports>>
<<pdf constants>>
<<pdf cache functions>>
<<doi resolution functions>>
<<pdf download functions>>
<<pdf open functions>>
@


\section{Testing}
\label{sec:pdf-tests}

Tests are distributed throughout this document, appearing after each
implementation section they verify.

<<test [[pdf.py]]>>=
"""Tests for the PDF module."""
import pytest
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

from scholar.pdf import *


<<test functions>>
@


\section{Imports and Constants}

<<pdf imports>>=
from pathlib import Path
from typing import Any, Callable
import hashlib
import os
import subprocess
import sys

import platformdirs
import requests
@

We define a constant for the subdirectory name within the cache directory.

<<pdf constants>>=
PDF_CACHE_SUBDIR = "pdfs"
@


\section{Cache Directory Management}

The PDF cache lives in the user's cache directory under a \enquote{pdfs}
subdirectory. This keeps PDFs separate from search result caches.

<<pdf cache functions>>=
def get_pdf_cache_dir() -> Path:
    """
    Get the PDF cache directory, creating it if needed.
    
    The cache location can be overridden with the SCHOLAR_CACHE_DIR
    environment variable.
    
    Returns:
        Path to the PDF cache directory.
    """
    base_cache = os.environ.get("SCHOLAR_CACHE_DIR")
    if base_cache:
        cache_dir = Path(base_cache) / PDF_CACHE_SUBDIR
    else:
        cache_dir = Path(platformdirs.user_cache_dir("scholar")) / PDF_CACHE_SUBDIR
    cache_dir.mkdir(parents=True, exist_ok=True)
    return cache_dir


def get_cached_pdf_path(url: str) -> Path:
    """
    Get the cache path for a PDF URL.
    
    Uses SHA-256 hash of the URL (truncated to 16 hex chars) as filename.
    This provides sufficient uniqueness while keeping paths readable.
    
    Args:
        url: The PDF URL.
    
    Returns:
        Path where this PDF would be cached.
    """
    url_hash = hashlib.sha256(url.encode()).hexdigest()[:16]
    return get_pdf_cache_dir() / f"{url_hash}.pdf"


def clear_pdf_cache() -> int:
    """
    Delete all cached PDFs.
    
    Returns:
        Number of PDF files deleted.
    """
    cache_dir = get_pdf_cache_dir()
    count = 0
    for pdf_file in cache_dir.glob("*.pdf"):
        try:
            pdf_file.unlink()
            count += 1
        except OSError:
            pass
    return count


def get_pdf_cache_info() -> dict[str, int]:
    """
    Get information about the PDF cache.
    
    Returns:
        Dictionary with 'count' (number of files) and 'size_bytes' (total size).
    """
    cache_dir = get_pdf_cache_dir()
    count = 0
    size_bytes = 0
    for pdf_file in cache_dir.glob("*.pdf"):
        count += 1
        try:
            size_bytes += pdf_file.stat().st_size
        except OSError:
            pass
    return {"count": count, "size_bytes": size_bytes}
@

\subsection{Testing cache functions}

<<test functions>>=
class TestPDFCache:
    """Tests for PDF cache functions."""

    def test_get_pdf_cache_dir_creates_directory(self, tmp_path, monkeypatch):
        """Cache directory is created if it doesn't exist."""
        cache_dir = tmp_path / "scholar_cache"
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(cache_dir))
        
        result = get_pdf_cache_dir()
        
        assert result == cache_dir / PDF_CACHE_SUBDIR
        assert result.exists()

    def test_get_cached_pdf_path_deterministic(self):
        """Same URL always produces same cache path."""
        url = "https://example.com/paper.pdf"
        path1 = get_cached_pdf_path(url)
        path2 = get_cached_pdf_path(url)
        assert path1 == path2

    def test_get_cached_pdf_path_different_urls(self):
        """Different URLs produce different cache paths."""
        url1 = "https://example.com/paper1.pdf"
        url2 = "https://example.com/paper2.pdf"
        path1 = get_cached_pdf_path(url1)
        path2 = get_cached_pdf_path(url2)
        assert path1 != path2

    def test_clear_pdf_cache(self, tmp_path, monkeypatch):
        """Can clear all cached PDFs."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        cache_dir = get_pdf_cache_dir()
        (cache_dir / "test1.pdf").write_bytes(b"pdf1")
        (cache_dir / "test2.pdf").write_bytes(b"pdf2")
        
        count = clear_pdf_cache()
        
        assert count == 2
        assert len(list(cache_dir.glob("*.pdf"))) == 0

    def test_get_pdf_cache_info(self, tmp_path, monkeypatch):
        """Can get cache statistics."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        cache_dir = get_pdf_cache_dir()
        (cache_dir / "test1.pdf").write_bytes(b"x" * 100)
        (cache_dir / "test2.pdf").write_bytes(b"y" * 200)
        
        info = get_pdf_cache_info()
        
        assert info["count"] == 2
        assert info["size_bytes"] == 300
@


\section{DOI Resolution}
\label{sec:doi-resolution}

When users have a DOI but not a direct PDF URL, we need to resolve the DOI
to find an open access PDF. We try multiple sources in order of reliability:

\begin{description}
\item[Unpaywall] The primary source for legal open access PDFs. Unpaywall
  maintains a database of open access versions of papers.
\item[Semantic Scholar] Provides PDF links for many papers in their database.
\item[DOI redirect] As a fallback, following the DOI redirect sometimes leads
  to a page with a PDF link.
\end{description}

\subsection{DOI Detection}

First, we need to detect whether an input string is a DOI. DOIs have a
standard format starting with \texttt{10.} followed by a registrant code
and a suffix.

<<doi resolution functions>>=
import re

DOI_PATTERN = re.compile(r'^10\.\d{4,}/[^\s]+$')
DOI_URL_PATTERN = re.compile(r'(?:https?://)?(?:dx\.)?doi\.org/(10\.\d{4,}/[^\s]+)')


def is_doi(identifier: str) -> bool:
    """
    Check if a string is a DOI.
    
    Accepts both raw DOIs (10.1234/example) and DOI URLs
    (https://doi.org/10.1234/example).
    
    Args:
        identifier: String to check.
    
    Returns:
        True if the string is a DOI or DOI URL.
    """
    identifier = identifier.strip()
    if DOI_PATTERN.match(identifier):
        return True
    if DOI_URL_PATTERN.match(identifier):
        return True
    return False


def extract_doi(identifier: str) -> str | None:
    """
    Extract the DOI from a string.
    
    Handles both raw DOIs and DOI URLs.
    
    Args:
        identifier: String potentially containing a DOI.
    
    Returns:
        The extracted DOI, or None if not a DOI.
    """
    identifier = identifier.strip()
    if DOI_PATTERN.match(identifier):
        return identifier
    match = DOI_URL_PATTERN.match(identifier)
    if match:
        return match.group(1)
    return None
@

\subsection{Unpaywall Resolution}

Unpaywall provides a free API to find open access versions of papers.
We query their API with the DOI and extract the PDF URL from the response.

<<doi resolution functions>>=
UNPAYWALL_API = "https://api.unpaywall.org/v2/{doi}"
UNPAYWALL_EMAIL = "scholar-cli@example.com"  # Required by Unpaywall API


def resolve_doi_unpaywall(
    doi: str,
    progress_callback: Callable[[str], None] | None = None,
) -> str | None:
    """
    Resolve a DOI to a PDF URL using Unpaywall.
    
    Args:
        doi: The DOI to resolve.
        progress_callback: Optional callback for status messages.
    
    Returns:
        PDF URL if found, None otherwise.
    """
    if progress_callback:
        progress_callback(f"Checking Unpaywall for {doi}...")
    
    try:
        url = UNPAYWALL_API.format(doi=doi)
        response = requests.get(
            url,
            params={"email": UNPAYWALL_EMAIL},
            timeout=10,
        )
        
        if response.status_code != 200:
            return None
        
        data = response.json()
        
        # Try best_oa_location first
        best_oa = data.get("best_oa_location")
        if best_oa and best_oa.get("url_for_pdf"):
            return best_oa["url_for_pdf"]
        
        # Fall back to any OA location with a PDF
        for location in data.get("oa_locations", []):
            if location.get("url_for_pdf"):
                return location["url_for_pdf"]
        
        return None
        
    except Exception:
        return None
@

\subsection{Semantic Scholar Resolution}

Semantic Scholar also provides PDF links for many papers. We query their
API using the DOI.

<<doi resolution functions>>=
S2_PAPER_API = "https://api.semanticscholar.org/graph/v1/paper/DOI:{doi}"


def resolve_doi_s2(
    doi: str,
    progress_callback: Callable[[str], None] | None = None,
) -> str | None:
    """
    Resolve a DOI to a PDF URL using Semantic Scholar.
    
    Args:
        doi: The DOI to resolve.
        progress_callback: Optional callback for status messages.
    
    Returns:
        PDF URL if found, None otherwise.
    """
    if progress_callback:
        progress_callback(f"Checking Semantic Scholar for {doi}...")
    
    try:
        url = S2_PAPER_API.format(doi=doi)
        response = requests.get(
            url,
            params={"fields": "openAccessPdf"},
            timeout=10,
        )
        
        if response.status_code != 200:
            return None
        
        data = response.json()
        oa_pdf = data.get("openAccessPdf")
        if oa_pdf and oa_pdf.get("url"):
            return oa_pdf["url"]
        
        return None
        
    except Exception:
        return None
@

\subsection{Combined DOI Resolution}

The main resolution function tries each source in order until it finds a PDF.

<<doi resolution functions>>=
def resolve_doi_to_pdf(
    doi: str,
    progress_callback: Callable[[str], None] | None = None,
) -> str:
    """
    Resolve a DOI to a PDF URL.
    
    Tries multiple sources in order: Unpaywall, Semantic Scholar.
    
    Args:
        doi: The DOI to resolve.
        progress_callback: Optional callback for status messages.
    
    Returns:
        PDF URL.
    
    Raises:
        PDFDownloadError: If no PDF URL could be found.
    """
    # Try Unpaywall first (best source for legal OA)
    url = resolve_doi_unpaywall(doi, progress_callback)
    if url:
        if progress_callback:
            progress_callback(f"Found PDF via Unpaywall")
        return url
    
    # Try Semantic Scholar
    url = resolve_doi_s2(doi, progress_callback)
    if url:
        if progress_callback:
            progress_callback(f"Found PDF via Semantic Scholar")
        return url
    
    # No PDF found
    raise PDFDownloadError(
        f"Could not find open access PDF for DOI: {doi}\n"
        f"The paper may not be available as open access."
    )
@

\subsection{Testing DOI resolution}

<<test functions>>=
class TestDOIResolution:
    """Tests for DOI resolution functions."""

    def test_is_doi_raw(self):
        """Recognizes raw DOI format."""
        assert is_doi("10.1234/test.paper")
        assert is_doi("10.48550/arXiv.2301.00001")

    def test_is_doi_url(self):
        """Recognizes DOI URLs."""
        assert is_doi("https://doi.org/10.1234/test")
        assert is_doi("http://dx.doi.org/10.1234/test")
        assert is_doi("doi.org/10.1234/test")

    def test_is_doi_false(self):
        """Rejects non-DOIs."""
        assert not is_doi("https://example.com/paper.pdf")
        assert not is_doi("not a doi")
        assert not is_doi("10.123/short")  # Too short registrant

    def test_extract_doi_raw(self):
        """Extracts raw DOI."""
        assert extract_doi("10.1234/test.paper") == "10.1234/test.paper"

    def test_extract_doi_from_url(self):
        """Extracts DOI from URL."""
        assert extract_doi("https://doi.org/10.1234/test") == "10.1234/test"
        assert extract_doi("http://dx.doi.org/10.5678/paper") == "10.5678/paper"

    def test_extract_doi_none(self):
        """Returns None for non-DOIs."""
        assert extract_doi("not a doi") is None
        assert extract_doi("https://example.com") is None

    def test_resolve_doi_unpaywall(self, monkeypatch):
        """Unpaywall resolution finds PDF URL."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "best_oa_location": {"url_for_pdf": "https://example.com/paper.pdf"}
        }
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            url = resolve_doi_unpaywall("10.1234/test")
        
        assert url == "https://example.com/paper.pdf"

    def test_resolve_doi_s2(self, monkeypatch):
        """Semantic Scholar resolution finds PDF URL."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "openAccessPdf": {"url": "https://arxiv.org/pdf/2301.00001.pdf"}
        }
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            url = resolve_doi_s2("10.1234/test")
        
        assert url == "https://arxiv.org/pdf/2301.00001.pdf"

    def test_resolve_doi_to_pdf_tries_sources(self, monkeypatch):
        """Combined resolution tries multiple sources."""
        # First call (Unpaywall) fails, second (S2) succeeds
        mock_response_fail = Mock()
        mock_response_fail.status_code = 404
        
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.json.return_value = {
            "openAccessPdf": {"url": "https://example.com/paper.pdf"}
        }
        
        with patch("scholar.pdf.requests.get", side_effect=[
            mock_response_fail, mock_response_success
        ]):
            url = resolve_doi_to_pdf("10.1234/test")
        
        assert url == "https://example.com/paper.pdf"

    def test_resolve_doi_to_pdf_no_pdf_raises(self):
        """Raises error when no PDF found."""
        mock_response = Mock()
        mock_response.status_code = 404
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            with pytest.raises(PDFDownloadError) as exc_info:
                resolve_doi_to_pdf("10.1234/no-pdf")
        
        assert "Could not find open access PDF" in str(exc_info.value)
@


\section{PDF Download}

The download function handles HTTP requests with proper error handling and
content-type validation. We verify the response is actually a PDF before
saving it.

<<pdf download functions>>=
class PDFDownloadError(Exception):
    """
    Exception raised when PDF download fails.
    
    Contains a descriptive error message suitable for display to users.
    """
    pass


def download_pdf(
    url: str,
    progress_callback: Callable[[str], None] | None = None,
) -> Path:
    """
    Download a PDF to the cache if not already cached.
    
    Args:
        url: URL of the PDF to download.
        progress_callback: Optional callback for status messages.
    
    Returns:
        Path to the cached PDF file.
    
    Raises:
        PDFDownloadError: If download fails with descriptive message.
    """
    cache_path = get_cached_pdf_path(url)
    
    if cache_path.exists():
        if progress_callback:
            progress_callback(f"Using cached PDF: {cache_path}")
        return cache_path
    
    if progress_callback:
        progress_callback(f"Downloading PDF from {url}...")
    
    try:
        response = requests.get(url, timeout=30, stream=True)
        response.raise_for_status()
        
        # Validate content type
        content_type = response.headers.get("content-type", "")
        if "pdf" not in content_type.lower() and "octet-stream" not in content_type.lower():
            raise PDFDownloadError(
                f"URL did not return a PDF. Content-Type: {content_type}\nURL: {url}"
            )
        
        # Stream to file
        with open(cache_path, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        
        if progress_callback:
            progress_callback("Download complete")
        
        return cache_path
        
    except requests.exceptions.HTTPError as e:
        raise PDFDownloadError(
            f"HTTP error {e.response.status_code}: {e.response.reason}\nURL: {url}"
        )
    except requests.exceptions.ConnectionError as e:
        raise PDFDownloadError(f"Connection error: {e}\nURL: {url}")
    except requests.exceptions.Timeout:
        raise PDFDownloadError(f"Request timed out after 30 seconds\nURL: {url}")
    except requests.exceptions.RequestException as e:
        raise PDFDownloadError(f"Request failed: {e}\nURL: {url}")
@

\subsection{High-level PDF access}

For convenience, we provide a function that accepts a Paper object, a DOI,
or a URL string, making it easy to use from both programmatic code and
the CLI/TUI.

<<pdf download functions>>=
def get_pdf(
    source: Any,
    progress_callback: Callable[[str], None] | None = None,
) -> Path:
    """
    Get a PDF, downloading if necessary.
    
    This is the main entry point for PDF access. It accepts:
    - A Paper object (using its pdf_url or doi attributes)
    - A DOI string (resolved via Unpaywall/Semantic Scholar)
    - A direct URL string
    
    Args:
        source: A Paper object, DOI string, or URL string.
        progress_callback: Optional callback for status messages.
    
    Returns:
        Path to the cached PDF file.
    
    Raises:
        PDFDownloadError: If download fails or no PDF available.
    """
    url: str | None = None
    
    if isinstance(source, str):
        # Check if it's a DOI
        doi = extract_doi(source)
        if doi:
            if progress_callback:
                progress_callback(f"Resolving DOI: {doi}")
            url = resolve_doi_to_pdf(doi, progress_callback)
        else:
            # Assume it's a URL
            url = source
    else:
        # Assume it's a Paper object
        # Try pdf_url first, then doi
        url = getattr(source, "pdf_url", None)
        if not url:
            doi = getattr(source, "doi", None)
            if doi:
                if progress_callback:
                    progress_callback(f"Resolving DOI: {doi}")
                url = resolve_doi_to_pdf(doi, progress_callback)
        if not url:
            raise PDFDownloadError(
                f"Paper has no PDF URL or DOI: {getattr(source, 'title', 'Unknown')}"
            )
    
    return download_pdf(url, progress_callback)
@

\subsection{Testing download functions}

<<test functions>>=
class TestPDFDownload:
    """Tests for PDF download functions."""

    def test_download_pdf_caches_result(self, tmp_path, monkeypatch):
        """Downloaded PDF is cached."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        # Mock requests.get
        mock_response = MagicMock()
        mock_response.headers = {"content-type": "application/pdf"}
        mock_response.iter_content.return_value = [b"PDF content"]
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            path = download_pdf("https://example.com/paper.pdf")
        
        assert path.exists()
        assert path.read_bytes() == b"PDF content"

    def test_download_pdf_uses_cache(self, tmp_path, monkeypatch):
        """Second download uses cached file."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        # Pre-create cached file
        url = "https://example.com/cached.pdf"
        cache_path = get_cached_pdf_path(url)
        cache_path.write_bytes(b"Cached PDF")
        
        # Should not make HTTP request
        with patch("scholar.pdf.requests.get") as mock_get:
            path = download_pdf(url)
            mock_get.assert_not_called()
        
        assert path == cache_path

    def test_download_pdf_validates_content_type(self, tmp_path, monkeypatch):
        """Rejects non-PDF content types."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        mock_response = MagicMock()
        mock_response.headers = {"content-type": "text/html"}
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            with pytest.raises(PDFDownloadError) as exc_info:
                download_pdf("https://example.com/not-a-pdf")
        
        assert "did not return a PDF" in str(exc_info.value)

    def test_get_pdf_from_paper(self, tmp_path, monkeypatch):
        """get_pdf works with Paper objects."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        paper = Mock()
        paper.pdf_url = "https://example.com/paper.pdf"
        paper.title = "Test Paper"
        
        mock_response = MagicMock()
        mock_response.headers = {"content-type": "application/pdf"}
        mock_response.iter_content.return_value = [b"PDF"]
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            path = get_pdf(paper)
        
        assert path.exists()

    def test_get_pdf_from_url_string(self, tmp_path, monkeypatch):
        """get_pdf works with URL strings."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        
        mock_response = MagicMock()
        mock_response.headers = {"content-type": "application/pdf"}
        mock_response.iter_content.return_value = [b"PDF"]
        
        with patch("scholar.pdf.requests.get", return_value=mock_response):
            path = get_pdf("https://example.com/paper.pdf")
        
        assert path.exists()

    def test_get_pdf_no_url_raises_error(self):
        """get_pdf raises error when paper has no PDF URL or DOI."""
        paper = Mock()
        paper.pdf_url = None
        paper.doi = None
        paper.title = "No PDF Paper"
        
        with pytest.raises(PDFDownloadError) as exc_info:
            get_pdf(paper)
        
        assert "no PDF URL or DOI" in str(exc_info.value)
@


\section{Opening PDFs}

We provide a cross-platform function to open PDFs with the system default
viewer. This delegates to platform-specific commands.

<<pdf open functions>>=
def open_pdf(path: Path) -> bool:
    """
    Open a PDF with the system default viewer.
    
    Uses platform-appropriate commands:
    - macOS: open
    - Windows: start
    - Linux/other: xdg-open
    
    Args:
        path: Path to the PDF file.
    
    Returns:
        True if the viewer was launched successfully, False otherwise.
    """
    try:
        if sys.platform == "darwin":
            subprocess.run(["open", str(path)], check=True)
        elif sys.platform == "win32":
            os.startfile(str(path))  # type: ignore
        else:
            subprocess.run(["xdg-open", str(path)], check=True)
        return True
    except Exception:
        return False
@

\subsection{Testing open function}

<<test functions>>=
class TestOpenPDF:
    """Tests for PDF open function."""

    def test_open_pdf_macos(self, tmp_path, monkeypatch):
        """Uses 'open' command on macOS."""
        monkeypatch.setattr(sys, "platform", "darwin")
        pdf_path = tmp_path / "test.pdf"
        pdf_path.write_bytes(b"PDF")
        
        with patch("scholar.pdf.subprocess.run") as mock_run:
            mock_run.return_value = None
            result = open_pdf(pdf_path)
        
        assert result is True
        mock_run.assert_called_once()
        assert "open" in mock_run.call_args[0][0]

    def test_open_pdf_linux(self, tmp_path, monkeypatch):
        """Uses 'xdg-open' command on Linux."""
        monkeypatch.setattr(sys, "platform", "linux")
        pdf_path = tmp_path / "test.pdf"
        pdf_path.write_bytes(b"PDF")
        
        with patch("scholar.pdf.subprocess.run") as mock_run:
            mock_run.return_value = None
            result = open_pdf(pdf_path)
        
        assert result is True
        mock_run.assert_called_once()
        assert "xdg-open" in mock_run.call_args[0][0]

    def test_open_pdf_failure_returns_false(self, tmp_path, monkeypatch):
        """Returns False when open command fails."""
        monkeypatch.setattr(sys, "platform", "linux")
        pdf_path = tmp_path / "test.pdf"
        pdf_path.write_bytes(b"PDF")
        
        with patch("scholar.pdf.subprocess.run", side_effect=Exception("Failed")):
            result = open_pdf(pdf_path)
        
        assert result is False
@
