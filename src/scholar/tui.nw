\chapter{Interactive Review Interface}
\label{tui-module}

\section{Introduction}

This module provides an interactive terminal user interface (TUI) for reviewing 
academic papers returned from search results. The TUI allows researchers to:
\begin{description}
\item[Browse] Navigate papers with vim-style keybindings
\item[View] Read paper abstracts and metadata
\item[Decide] Keep or discard papers with mandatory motivations for discards
\item[Annotate] Add and edit notes for papers (persisted globally)
\item[Sort] Order papers by various criteria
\item[Report] Generate \LaTeX\ reports of the review session
\end{description}

The TUI supports two modes:
\begin{description}
\item[Review mode] Used when reviewing search results, with keep/discard 
  functionality enabled and decisions saved per-query.
\item[Notes mode] Used when browsing papers with notes, with keep/discard 
  disabled but note editing still available.
\end{description}

The interface is built using Textual, a modern Python TUI framework that
provides rich terminal interfaces with mouse support and responsive layouts.

\section{Architecture Overview}
\label{sec:tui-architecture}

Before diving into implementation, it helps to understand Textual's
architecture and how our components fit together.

Textual applications follow a hierarchical structure:
\begin{description}
\item[App] The root container that manages screens, keybindings, and
  application lifecycle. Our [[PaperReviewApp]] inherits from this.
\item[Screen] A full-screen view that can be pushed onto a stack. We use
  [[AbstractScreen]] for viewing paper details, and return to the main
  screen when dismissed.
\item[ModalScreen] A screen that overlays the current screen rather than
  replacing it. We use modals for [[DiscardModal]], [[SortModal]], and
  [[FilterModal]] to capture user input while keeping context visible.
\item[Widget] Reusable UI components that compose to form screens. Our
  [[PaperListItem]] is a custom widget displaying paper metadata.
\end{description}

The data flow through these components follows a clear pattern:
\begin{enumerate}
\item Search results arrive as [[SearchResult]] objects (from [[scholar.py]])
\item We convert them to [[ReviewDecision]] objects tracking review state
\item The TUI displays and allows modification of these decisions
\item On exit, decisions are persisted via [[notes.py]] functions
\end{enumerate}

This separation keeps the TUI focused on presentation while delegating
persistence to the [[notes]] module (see \autoref{notes-module}).

\section{User Workflow}

A typical review session proceeds as follows:
\begin{enumerate}
\item User runs [[scholar search --review "query"]]
\item Papers appear in a scrollable list with vim-style navigation
\item User selects papers to view abstracts (Enter key)
\item For each paper, user decides: Keep (\texttt{K}) or Discard (\texttt{d})
\item Discards require a motivation (for audit trail)
\item After reviewing, user can filter to see only kept/discarded/pending
\item On exit, a \LaTeX\ report can be generated documenting decisions
\end{enumerate}

\section{Module Structure}

The TUI module exports functions for launching the interactive review interface
and generating reports from review sessions.

The module is organized to mirror the screen hierarchy described above.
We define data structures first (needed by all components), then build up
from simple widgets to complex screens, culminating in the main application:

<<[[tui.py]]>>=
"""Interactive TUI for reviewing academic papers."""
<<tui imports>>
<<tui data structures>>
<<tui pdf cache>>
<<tui paper list widget>>
<<tui abstract screen>>
<<tui discard modal>>
<<tui sort modal>>
<<tui filter modal>>
<<tui main app>>
<<tui report generation>>
<<tui entry point>>
@


\section{Testing}
\label{sec:tui-tests}

Tests are distributed throughout this document, appearing after each
implementation section they verify. This follows literate programming
best practice: tests serve as proof of correctness and examples of usage,
so they belong near the code they verify.

The test file collects all distributed test chunks:

<<test [[tui.py]]>>=
"""Tests for the TUI module."""
import pytest
from datetime import datetime

from scholar import *
from scholar.tui import *


<<test functions>>
@


\section{Data Structures}

We need data structures to track the review state of each paper. The 
[[ReviewDecision]] captures whether a paper is kept, discarded, or still 
pending review, along with the motivation for discards. These data structures
are now provided by the [[review]] module.

<<tui imports>>=
from datetime import datetime
from pathlib import Path

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal, Vertical, VerticalScroll
from textual.screen import Screen, ModalScreen
from textual.widgets import (
    Button, DataTable, Footer, Header, Input, Label,
    ListItem, ListView, Markdown, OptionList, SelectionList, Static, TextArea,
)
from textual.widgets.selection_list import Selection
from textual.message import Message
from textual import work
from rich.text import Text
from rich.console import Console

from scholar.scholar import Paper, SearchResult
from scholar.notes import (
    get_note, has_note, edit_note_in_editor,
)
from scholar.review import (
    DecisionStatus, ReviewDecision, ReviewSession,
    create_review_session, save_search_decisions,
    escape_latex,
)
from scholar.pdf import (
    get_pdf_cache_dir, get_cached_pdf_path, download_pdf, open_pdf, PDFDownloadError,
)
@

The data structures for review decisions ([[DecisionStatus]], [[ReviewDecision]], 
and [[ReviewSession]]) are now provided by the [[review]] module 
(\autoref{review-module}). The TUI imports and uses these directly, enabling
the same review logic to be used programmatically without the TUI.

<<tui data structures>>=
# Data structures imported from scholar.review:
# - DecisionStatus: Enum for pending/kept/discarded
# - ReviewDecision: Decision for a single paper with tags
# - ReviewSession: Complete review session with all decisions
#
# The review module's ReviewDecision uses tags: list[str] instead of motivation: str,
# with a backward-compatible motivation property that accesses the first tag.
@

\section{PDF Caching}
\label{sec:pdf-cache}

PDF caching functionality is provided by the [[pdf]] module 
(\autoref{pdf-module}). The TUI imports and uses these functions directly:
\begin{description}
\item[\texttt{get\_pdf\_cache\_dir()}] Returns the cache directory path.
\item[\texttt{get\_cached\_pdf\_path(url)}] Returns the cache path for a URL.
\item[\texttt{download\_pdf(url)}] Downloads a PDF to the cache.
\item[\texttt{open\_pdf(path)}] Opens a PDF with the system viewer.
\item[\texttt{PDFDownloadError}] Exception for download failures.
\end{description}

<<tui pdf cache>>=
# PDF caching functions imported from scholar.pdf:
# - get_pdf_cache_dir(): Get cache directory
# - get_cached_pdf_path(url): Get cache path for URL
# - download_pdf(url): Download PDF to cache
# - open_pdf(path): Open PDF with system viewer
# - PDFDownloadError: Exception for download failures
@

\section{Paper List Widget}
\label{sec:paper-list-widget}

The main interface displays papers in a navigable list. Each paper shows its
title, authors, year, and current review status using color coding.

\subsection{Widget Composition in Textual}

Textual uses a composition model where complex interfaces are built from
simple widgets. Our [[PaperListItem]] extends [[ListItem]] (a built-in widget)
and yields [[Static]] widgets containing formatted text.

The [[compose]] method is Textual's pattern for declarative UI: rather than
imperatively creating and adding widgets, we yield the widgets we want and
Textual handles layout and rendering.

\subsection{Visual Feedback Through Color}

Color coding provides immediate visual feedback about review progress:
\begin{description}
\item[Green checkmark (\texttt{‚úì})] Paper marked as kept
\item[Red cross (\texttt{‚úó})] Paper marked as discarded
\item[Dim circle (\texttt{‚óã})] Paper still pending review
\item[Yellow notepad (\texttt{üìù})] Paper has attached notes
\end{description}

In notes-only mode, we hide the status indicator since keep/discard
doesn't apply---the user is just browsing papers with notes.

<<tui paper list widget>>=
class PaperListItem(ListItem):
    """A list item displaying a paper with its review status."""
    
    def __init__(self, decision: ReviewDecision, index: int, review_mode: bool = True) -> None:
        super().__init__()
        self.decision = decision
        self.index = index
        self.review_mode = review_mode
    
    def compose(self) -> ComposeResult:
        paper = self.decision.paper
        status = self.decision.status
        
        # Note indicator
        note_indicator = "[yellow]üìù[/yellow] " if has_note(paper) else "   "
        
        # Color code by status (only in review mode)
        if self.review_mode:
            if status == DecisionStatus.KEPT:
                status_indicator = "[green]‚úì[/green]"
            elif status == DecisionStatus.DISCARDED:
                status_indicator = "[red]‚úó[/red]"
            else:
                status_indicator = "[dim]‚óã[/dim]"
        else:
            status_indicator = " "
        
        # Format authors (truncate if too many)
        authors = ", ".join(paper.authors[:3])
        if len(paper.authors) > 3:
            authors += " et al."
        
        year = paper.year or "n/a"
        provider = f"[dim]{self.decision.provider}[/dim]"
        
        yield Static(
            f"{status_indicator} {note_indicator}{paper.title[:55]}{'...' if len(paper.title) > 55 else ''}\n"
            f"   [dim]{authors} ({year})[/dim] {provider}"
        )
@

\section{Abstract Viewing Screen}
\label{sec:abstract-screen}

When the user presses Enter on a paper, we show a full-screen view of the
abstract along with all paper metadata. This screen allows the user to read
the full abstract and make a decision about the paper.

\subsection{Screen Lifecycle and Navigation}

Textual screens form a stack. When we [[push_screen]], the new screen
appears on top; when we [[dismiss]], we return to the previous screen.
This matches the natural mental model: drilling into a paper (push),
then returning to the list (dismiss).

The abstract screen provides several actions:
\begin{description}
\item[Keep (\texttt{K})] Quick keep---mark paper as kept without themes, return to list
\item[Themes (\texttt{T})] Keep with themes---open theme selection modal, then return
\item[Discard (\texttt{d})] Open motivation selection modal, then return
\item[Notes (\texttt{n})] Open external editor for paper notes
\item[PDF (\texttt{p})] Download and open the paper's PDF
\item[Back (Escape/q)] Return to list without changing status
\end{description}

The distinction between \texttt{K} (quick keep) and \texttt{T} (keep with themes)
supports different workflows. During initial screening, reviewers often want to
quickly mark obviously relevant papers. Later, when organizing kept papers for
thematic analysis, they can use \texttt{T} to add themes.

\subsection{External Editor Integration}

For note editing, we use [[self.app.suspend()]] which temporarily releases
the terminal back to the shell, allowing the user's preferred editor (from
[[VISUAL]] or [[EDITOR]] environment variables) to run. This leverages
familiar tools rather than implementing a text editor in the TUI.

<<tui abstract screen>>=
class AbstractScreen(Screen[None]):
    """Full-screen view of a paper's abstract and details."""
    
    BINDINGS = [
        Binding("escape", "dismiss_screen", "Back"),
        Binding("q", "dismiss_screen", "Back"),
        Binding("K", "keep", "Keep"),
        Binding("T", "keep_with_themes", "Themes"),
        Binding("d", "discard", "Discard"),
        Binding("p", "open_pdf", "Open PDF"),
        Binding("n", "edit_notes", "Notes"),
    ]
    
    def __init__(self, decision: ReviewDecision, session: ReviewSession, review_mode: bool = True) -> None:
        super().__init__()
        self.decision = decision
        self.session = session
        self.review_mode = review_mode
        self.pdf_status: str = ""
    
    def compose(self) -> ComposeResult:
        paper = self.decision.paper
        
        yield Header()
        with VerticalScroll():
            yield Static(f"[bold]{paper.title}[/bold]", classes="title")
            yield Static(f"[dim]Provider: {self.decision.provider}[/dim]")
            yield Static("")
            
            authors = ", ".join(paper.authors) if paper.authors else "Unknown"
            yield Static(f"[bold]Authors:[/bold] {authors}")
            yield Static(f"[bold]Year:[/bold] {paper.year or 'Unknown'}")
            yield Static(f"[bold]Venue:[/bold] {paper.venue or 'Unknown'}")
            
            if paper.doi:
                yield Static(f"[bold]DOI:[/bold] {paper.doi}")
            if paper.url:
                yield Static(f"[bold]URL:[/bold] {paper.url}")
            if paper.pdf_url:
                yield Static(f"[bold]PDF:[/bold] {paper.pdf_url}")
            
            yield Static("")
            yield Static("[bold]Abstract:[/bold]")
            if paper.abstract:
                yield Static(paper.abstract)
            else:
                if paper.pdf_url:
                    yield Static("[dim]No abstract available. Press [bold yellow]p[/bold yellow] to open PDF.[/dim]")
                else:
                    yield Static("[dim]No abstract available and no PDF link found.[/dim]")
            
            # Show notes section if paper has notes
            note = get_note(paper)
            if note:
                yield Static("")
                yield Static("[bold cyan]‚îÄ‚îÄ‚îÄ Notes ‚îÄ‚îÄ‚îÄ[/bold cyan]")
                yield Markdown(note.note, id="notes-content")
            else:
                yield Static("")
                yield Static("[dim]No notes. Press [bold yellow]n[/bold yellow] to add notes.[/dim]")
            
            yield Static("", id="pdf-status")
        yield Footer()
    
    def action_edit_notes(self) -> None:
        """Open editor to edit notes for this paper."""
        paper = self.decision.paper
        with self.app.suspend():
            edit_note_in_editor(paper)
        # Refresh the screen to show updated notes
        self.refresh(recompose=True)
    
    def action_open_pdf(self) -> None:
        """Download and open the PDF."""
        paper = self.decision.paper
        
        if not paper.pdf_url:
            self.notify("No PDF URL available", severity="error")
            return
        
        cache_path = get_cached_pdf_path(paper.pdf_url)
        
        if cache_path.exists():
            self.notify(f"Using cached PDF", severity="information")
        else:
            self.notify(f"Downloading PDF...", severity="information")
            try:
                download_pdf(paper.pdf_url)
                self.notify("Download complete", severity="information")
            except PDFDownloadError as e:
                self.notify(f"Download failed: {e}", severity="error")
                return
        
        if open_pdf(cache_path):
            self.notify("PDF opened", severity="information")
        else:
            self.notify("Failed to open PDF viewer", severity="error")
    
    async def action_dismiss_screen(self) -> None:
        """Return to the paper list."""
        self.dismiss(None)
    
    def action_keep(self) -> None:
        """Quick keep---mark paper as kept without themes."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        self.decision.status = DecisionStatus.KEPT
        self.decision.clear_tags()
        self.dismiss(None)
    
    def action_keep_with_themes(self) -> None:
        """Keep with themes---open theme selection modal."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        
        def handle_themes(result: list[str] | None) -> None:
            if result is not None:  # None means cancelled
                self.decision.status = DecisionStatus.KEPT
                self.decision.tags = result
                self.dismiss(None)
        
        self.app.push_screen(
            TagSelectionModal(
                title=f"Themes: {self.decision.paper.title[:50]}...",
                available_tags=list(self.session.all_themes()),
                tag_counts=self.session.theme_counts(),
                selected_tags=self.decision.tags,
                require_at_least_one=False,
            ),
            handle_themes,
        )
    
    def action_discard(self) -> None:
        """Open motivation selection modal."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        
        def handle_discard(result: list[str] | None) -> None:
            if result is not None:  # None means cancelled
                self.decision.status = DecisionStatus.DISCARDED
                self.decision.tags = result
                self.dismiss(None)
        
        self.app.push_screen(
            TagSelectionModal(
                title=f"Motivations: {self.decision.paper.title[:50]}...",
                available_tags=list(self.session.all_motivations()),
                tag_counts=self.session.motivation_counts(),
                selected_tags=self.decision.tags,
                require_at_least_one=True,
            ),
            handle_discard,
        )
@

\section{Tag Selection Modal}
\label{sec:tag-selection-modal}

Systematic literature reviews require careful documentation of decisions.
When excluding a paper, reviewers must record \emph{why}---this creates an
audit trail that other researchers can verify. When including a paper,
tagging it with themes helps organize the final synthesis.

The original design used separate interfaces: a simple input for discard
motivations, and no interface for themes. This created two problems:
\begin{enumerate}
\item Reviewers typed the same motivations repeatedly (e.g., \enquote{not 
  peer-reviewed}, \enquote{wrong domain})
\item Kept papers had no organizational structure for thematic analysis
\end{enumerate}

Our solution is a unified \emph{tag selection modal} that serves both purposes.
By reusing the same component, we ensure consistent UX and reduce code
duplication.

\subsection{Design: Checklist with Counts}

We chose a checklist interface over single-selection for several reasons:
\begin{description}
\item[Multiple motivations] A paper might be excluded for several reasons
  (e.g., both \enquote{not peer-reviewed} AND \enquote{wrong methodology}).
  Recording all reasons improves the audit trail.
\item[Multiple themes] Kept papers often span multiple research themes.
  A paper on \enquote{authentication} might also relate to \enquote{usability}.
\item[Reuse existing tags] Showing previously used tags with counts
  (e.g., \enquote{off-topic (12)}) helps reviewers maintain consistency
  and see which exclusion criteria are most common.
\end{description}

The modal uses Textual's [[SelectionList]] widget, which renders as a
scrollable list of checkboxes. Each tag displays its usage count in
parentheses, helping reviewers understand the distribution of decisions.

\subsection{Interaction Design}

The modal supports three key interactions:
\begin{description}
\item[Toggle existing tags] Press Space or click to check/uncheck tags
  in the list. Multiple tags can be selected simultaneously.
\item[Add new tags] Press Tab to move to the input field, type a tag name,
  and press Enter. The new tag appears in the list and is automatically 
  selected. The input clears so users can add more tags without extra 
  keystrokes.
\item[Confirm selection] Press Enter to confirm and close the modal.
  This works from both the selection list and the input field.
\end{description}

For discarding papers, the modal enforces that at least one motivation
must be selected---we pass [[require_at_least_one=True]]. For keeping
papers with themes, selection is optional.

\subsubsection{Focus Management}

Initial focus depends on whether there are existing tags to choose from.
If the list has tags, we focus the [[SelectionList]] so users can immediately
toggle selections with Space. If the list is empty (first time discarding
or adding themes), we focus the [[Input]] field since there's nothing to
select yet.

An earlier design always focused the [[SelectionList]] and relied on
[[on_input_submitted]] to handle Enter. This failed because:
\begin{enumerate}
\item The [[SelectionList]] widget captures keyboard input but doesn't
  pass text to the [[Input]] field---typing while the list has focus
  does nothing useful.
\item The [[on_input_submitted]] event only fires when the [[Input]] widget
  has focus and receives Enter. With focus on the [[SelectionList]], 
  pressing Enter did nothing.
\item Users had to know to press Tab to reach the input field, but this
  wasn't documented and wasn't discoverable.
\end{enumerate}

The fix adds an [[enter]] binding at the modal level via [[action_confirm]].
This binding fires regardless of which widget has focus. The action checks
whether the [[Input]] has focus: if so and it contains text, the text is
added as a new tag; otherwise, the selection is confirmed. This means
Enter always does something sensible.

\subsection{Code Reuse Through Parameterization}

Rather than creating separate [[DiscardModal]] and [[ThemeModal]] classes,
we parameterize a single [[TagSelectionModal]]:
\begin{description}
\item[title] Describes the action (\enquote{Select motivations...} vs
  \enquote{Select themes...})
\item[available\_tags] Previous motivations or themes from the session
\item[tag\_counts] How many papers use each tag (for display)
\item[selected\_tags] Pre-selected tags (when editing an existing decision)
\item[require\_at\_least\_one] Enforces selection for discards
\end{description}

This approach follows the DRY principle while maintaining semantic clarity
at each call site.

<<tui discard modal>>=
class TagSelectionModal(ModalScreen[list[str] | None]):
    """Modal for selecting multiple tags from a checklist.
    
    Used for both motivations (discarding) and themes (keeping).
    Shows a SelectionList of existing tags with checkboxes,
    plus an Input to add new tags.
    
    Args:
        title: Modal title displayed at the top.
        available_tags: List of existing tags to show.
        tag_counts: Optional dict mapping tags to usage counts.
        selected_tags: Tags that should be pre-selected.
        require_at_least_one: If True, dismissal requires selection.
    
    Returns:
        List of selected tag strings, or None if cancelled.
    """
    
    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
        Binding("enter", "confirm", "Confirm"),
    ]
    
    DEFAULT_CSS = """
    TagSelectionModal {
        align: center middle;
    }
    #tag-dialog {
        width: 70;
        height: auto;
        max-height: 80%;
        padding: 1 2;
        border: thick $primary;
        background: $surface;
    }
    #tag-title {
        margin-bottom: 1;
    }
    #tag-list {
        height: auto;
        max-height: 15;
        margin-bottom: 1;
        border: solid $primary-darken-2;
    }
    #tag-input {
        margin-top: 1;
    }
    #tag-help {
        margin-top: 1;
        color: $text-muted;
    }
    """
    
    def __init__(
        self,
        title: str,
        available_tags: list[str],
        tag_counts: dict[str, int] | None = None,
        selected_tags: list[str] | None = None,
        require_at_least_one: bool = False,
    ) -> None:
        super().__init__()
        self.title_text = title
        # Deduplicate while preserving order
        self.available_tags = list(dict.fromkeys(available_tags))
        self.tag_counts = tag_counts or {}
        self.selected_tags = set(selected_tags or [])
        self.require_at_least_one = require_at_least_one
@

\subsection{Building the Selection List}

The [[compose]] method builds the modal's widget tree. We create a
[[Selection]] object for each available tag, incorporating the usage
count into the display label. Tags that were previously selected
(passed via [[selected_tags]]) start in the checked state.

<<tui discard modal>>=
    def compose(self) -> ComposeResult:
        with Container(id="tag-dialog"):
            yield Static(f"[bold]{self.title_text}[/bold]", id="tag-title")
            
            # Build selection list with counts
            selections = []
            for tag in self.available_tags:
                count = self.tag_counts.get(tag, 0)
                label = f"{tag} ({count})" if count > 0 else tag
                is_selected = tag in self.selected_tags
                selections.append(Selection(label, tag, initial_state=is_selected))
            
            yield SelectionList[str](*selections, id="tag-list")
            yield Input(
                placeholder="Type new tag and press Enter (empty to confirm)",
                id="tag-input",
            )
            
            # Show contextual help, noting if selection is required
            help_text = "[dim]Space: toggle, Enter: confirm, Tab: add new, Escape: cancel[/dim]"
            if self.require_at_least_one:
                help_text = "[dim]At least one required. " + help_text[5:]
            yield Static(help_text, id="tag-help")
    
    def on_mount(self) -> None:
        """Focus appropriate widget based on available tags."""
        if self.available_tags:
            self.query_one("#tag-list", SelectionList).focus()
        else:
            self.query_one("#tag-input", Input).focus()
@

\subsection{Handling Input}

The input field serves dual purposes: adding new tags and confirming
selection. We distinguish these by checking whether the input is empty.

When adding a new tag, we check if it already exists in the list. If so,
we simply select it (in case the user didn't notice it). If not, we add
it to the [[SelectionList]] and mark it as selected. The input clears
afterward, ready for additional tags.

<<tui discard modal>>=
    def on_input_submitted(self, event: Input.Submitted) -> None:
        """Handle Enter in input field."""
        tag = event.value.strip()
        if tag:
            # Add new tag to list and auto-select it
            self._add_and_select_tag(tag)
            event.input.value = ""  # Clear for more input
        else:
            # Empty input = confirm selection
            self._confirm_selection()
    
    def _add_and_select_tag(self, tag: str) -> None:
        """Add a new tag to the list and select it."""
        selection_list = self.query_one("#tag-list", SelectionList)
        
        # Check if tag already exists (user might not have noticed it)
        # Use public API: iterate with get_option_at_index
        for i in range(selection_list.option_count):
            option = selection_list.get_option_at_index(i)
            if option.value == tag:
                # Tag exists - just select it if not already selected
                if tag not in selection_list.selected:
                    selection_list.select(tag)
                return
        
        # Add new tag (no count since it's new to this session)
        selection_list.add_option(Selection(tag, tag, initial_state=True))
@

\subsection{Confirmation and Cancellation}

When confirming, we validate that at least one tag is selected if
[[require_at_least_one]] is set. This enforces the systematic review
requirement that exclusions must be justified.

The modal returns [[None]] on cancellation, allowing callers to
distinguish between \enquote{user cancelled} and \enquote{user selected
zero tags} (the latter only valid when [[require_at_least_one=False]]).

<<tui discard modal>>=
    def _confirm_selection(self) -> None:
        """Confirm the current selection and dismiss."""
        selection_list = self.query_one("#tag-list", SelectionList)
        selected = list(selection_list.selected)
        
        if self.require_at_least_one and not selected:
            self.notify("At least one selection required", severity="warning")
            return
        
        self.dismiss(selected)
    
    def action_cancel(self) -> None:
        """Cancel without making changes."""
        self.dismiss(None)
    
    def action_confirm(self) -> None:
        """Confirm selection when Enter pressed."""
        input_widget = self.query_one("#tag-input", Input)
        if input_widget.has_focus:
            # Input has focus - if there's text, add it; otherwise confirm
            tag = input_widget.value.strip()
            if tag:
                self._add_and_select_tag(tag)
                input_widget.value = ""
            else:
                self._confirm_selection()
        else:
            # SelectionList has focus - just confirm
            self._confirm_selection()
@

\section{Sort Modal}
\label{sec:sort-modal}

The sort modal allows users to change the sort order of papers. Sorting helps
users organize papers by relevance criteria like year or author.

\subsection{Why Sorting Matters for Review}

Different sorting strategies support different review workflows:
\begin{description}
\item[By year (newest first)] Review recent work first to understand current
  state of the art before examining older foundational papers
\item[By year (oldest first)] Trace historical development of a field,
  understanding how ideas evolved over time
\item[By author] Group papers by research group, helpful when tracking
  specific authors' contributions to a topic
\item[By title] Alphabetical ordering for systematic comparison with
  existing bibliographies or reference lists
\item[By provider] See which databases contributed which papers, useful
  for understanding search coverage
\end{description}

\subsection{Keyboard-First Design}

We use single-letter shortcuts (case-sensitive) for immediate action:
lowercase for ascending order, uppercase for descending. This follows
the vim philosophy of mnemonic keys: \texttt{t} for title, \texttt{y}
for year, \texttt{a} for author.

The case distinction (e.g., \texttt{y} vs \texttt{Y}) provides a natural
way to express ascending/descending without additional modifier keys.

<<tui sort modal>>=
class SortModal(ModalScreen[tuple[str, bool] | None]):
    """Modal dialog to select sort criteria."""
    
    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
        Binding("t", "sort_title", "Title A-Z", priority=True),
        Binding("T", "sort_title_rev", "Title Z-A", priority=True),
        Binding("y", "sort_year", "Year ‚Üë", priority=True),
        Binding("Y", "sort_year_rev", "Year ‚Üì", priority=True),
        Binding("a", "sort_author", "Author A-Z", priority=True),
        Binding("A", "sort_author_rev", "Author Z-A", priority=True),
        Binding("p", "sort_provider", "Provider", priority=True),
    ]
    
    DEFAULT_CSS = """
    SortModal {
        align: center middle;
    }
    #sort-dialog {
        width: 50;
        height: auto;
        border: thick $primary;
        background: $surface;
        padding: 1 2;
    }
    #sort-title {
        text-align: center;
        width: 100%;
        margin-bottom: 1;
    }
    .sort-option {
        margin: 0 1;
    }
    .key {
        color: $warning;
        text-style: bold;
    }
    """
    
    def compose(self) -> ComposeResult:
        with Container(id="sort-dialog"):
            yield Static("[bold]Sort Papers[/bold]", id="sort-title")
            yield Static("")
            yield Static("[bold yellow]t[/] Title (A‚ÜíZ)    [bold yellow]T[/] Title (Z‚ÜíA)")
            yield Static("[bold yellow]y[/] Year (oldest)  [bold yellow]Y[/] Year (newest)")
            yield Static("[bold yellow]a[/] Author (A‚ÜíZ)   [bold yellow]A[/] Author (Z‚ÜíA)")
            yield Static("[bold yellow]p[/] Provider")
            yield Static("")
            yield Static("[dim]Press [bold]Escape[/bold] to cancel[/dim]")
    
    def action_cancel(self) -> None:
        self.dismiss(None)
    
    def action_sort_title(self) -> None:
        self.dismiss(("title", False))
    
    def action_sort_title_rev(self) -> None:
        self.dismiss(("title", True))
    
    def action_sort_year(self) -> None:
        self.dismiss(("year", False))
    
    def action_sort_year_rev(self) -> None:
        self.dismiss(("year", True))
    
    def action_sort_author(self) -> None:
        self.dismiss(("author", False))
    
    def action_sort_author_rev(self) -> None:
        self.dismiss(("author", True))
    
    def action_sort_provider(self) -> None:
        self.dismiss(("provider", False))
@

\section{Filter Modal}
\label{FilterModal}

When reviewing large search results, users often want to focus on specific 
subsets of papers. For example, after an initial pass through all papers, a 
reviewer might want to revisit only the kept papers to write detailed notes, or 
focus exclusively on pending papers to complete the review.

The filter modal provides four filter options:
\begin{description}
\item[All] Shows all papers regardless of decision status (the default view).
\item[Kept] Shows only papers marked for keeping, useful for focused note-taking 
  or generating a report of selected papers.
\item[Discarded] Shows only discarded papers, helpful for reconsidering previous 
  rejections.
\item[Pending] Shows only papers awaiting decision, enabling efficient 
  batch-processing of unreviewed items.
\end{description}

We use the same keybindings as the main decision actions for consistency: 
\texttt{K} for kept (matching the keep action) and \texttt{d} for discarded 
(matching the discard action). This reduces cognitive load by maintaining a 
consistent mental model throughout the interface.

<<tui filter modal>>=
class FilterModal(ModalScreen[str | None]):
    """Modal dialog to select paper filter by decision status."""
    
    BINDINGS = [
        Binding("escape", "cancel", "Cancel"),
        Binding("a", "filter_all", "All", priority=True),
        Binding("K", "filter_kept", "Kept", priority=True),
        Binding("d", "filter_discarded", "Discarded", priority=True),
        Binding("p", "filter_pending", "Pending", priority=True),
    ]
    
    DEFAULT_CSS = """
    FilterModal {
        align: center middle;
    }
    #filter-dialog {
        width: 40;
        height: auto;
        border: thick $primary;
        background: $surface;
        padding: 1 2;
    }
    #filter-title {
        text-align: center;
        width: 100%;
        margin-bottom: 1;
    }
    """
    
    def compose(self) -> ComposeResult:
        with Container(id="filter-dialog"):
            yield Static("[bold]Filter Papers[/bold]", id="filter-title")
            yield Static("")
            yield Static("[bold yellow]a[/] All papers")
            yield Static("[bold yellow]K[/] Kept only")
            yield Static("[bold yellow]d[/] Discarded only")
            yield Static("[bold yellow]p[/] Pending only")
            yield Static("")
            yield Static("[dim]Press [bold]Escape[/bold] to cancel[/dim]")
    
    def action_cancel(self) -> None:
        self.dismiss(None)
    
    def action_filter_all(self) -> None:
        self.dismiss("all")
    
    def action_filter_kept(self) -> None:
        self.dismiss("kept")
    
    def action_filter_discarded(self) -> None:
        self.dismiss("discarded")
    
    def action_filter_pending(self) -> None:
        self.dismiss("pending")
@

\section{Main Application}
\label{sec:main-app}

The main TUI application coordinates all the screens and manages the review
session state. It provides vim-style keybindings for efficient navigation.

\subsection{Application Architecture}

The [[PaperReviewApp]] class serves as the orchestrator, responsible for:
\begin{description}
\item[State management] Tracking the [[ReviewSession]] with all decisions
\item[Screen coordination] Pushing/popping screens and modals as users navigate
\item[Callback handling] Processing results when screens are dismissed
\item[View filtering] Maintaining which subset of papers is currently displayed
\end{description}

The app maintains two key state variables beyond the session:
\begin{itemize}
\item [[current_index]]: Which paper is selected (for restoring position)
\item [[current_filter]]: Which papers are shown (all/kept/discarded/pending)
\end{itemize}

\subsection{Filtering by Decision Status}

When working with large search results, users need the ability to focus on 
specific subsets of papers. The application maintains a \emph{current filter} 
state that determines which papers are displayed in the list view. This filter 
can be set to:
\begin{description}
\item[all] Display all papers regardless of status (the default).
\item[kept] Display only papers marked for keeping---useful for reviewing 
  selections before generating a report or for focused note-taking on accepted 
  papers.
\item[discarded] Display only discarded papers---helpful when reconsidering 
  previous rejections or documenting reasons for exclusion.
\item[pending] Display only papers awaiting decision---enables efficient 
  batch-processing when returning to an incomplete review session.
\end{description}

The filtering works by maintaining the full session data unchanged while 
presenting a filtered \emph{view} of the decisions list. This means changing 
the filter never loses data; it simply changes what is currently visible.

When a filter is active, the status bar displays the current filter name and 
the count of matching papers, providing clear feedback about what subset is 
being viewed.

<<tui main app>>=
class PaperReviewApp(App):
    """Interactive paper review application."""
    
    CSS = """
    #paper-list {
        height: 1fr;
    }
    
    #status-bar {
        dock: bottom;
        height: 1;
        background: $primary;
        color: $text;
        padding: 0 1;
    }
    
    #discard-dialog {
        width: 60;
        height: auto;
        padding: 1 2;
        background: $surface;
        border: solid $primary;
    }
    
    #discard-buttons {
        margin-top: 1;
        height: auto;
    }
    
    #discard-buttons Button {
        margin-right: 1;
    }
    
    #motivation-input {
        height: 5;
        margin: 1 0;
    }
    
    #sort-dialog {
        width: 40;
        height: auto;
        padding: 1 2;
        background: $surface;
        border: solid $primary;
    }
    
    .title {
        margin-bottom: 1;
    }
    """
    
    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("j", "cursor_down", "Down", show=False),
        Binding("k", "cursor_up", "Up", show=False),
        Binding("down", "cursor_down", "Down", show=False),
        Binding("up", "cursor_up", "Up", show=False),
        Binding("K", "keep", "Keep"),
        Binding("T", "keep_with_themes", "Themes"),
        Binding("d", "discard", "Discard"),
        Binding("s", "sort", "Sort"),
        Binding("f", "filter", "Filter"),
        Binding("n", "edit_notes", "Notes"),
    ]
    
    def __init__(self, session: ReviewSession, review_mode: bool = True) -> None:
        super().__init__()
        self.session = session
        self.review_mode = review_mode
        self.current_index = 0
        self.current_filter = "all"
    
    def compose(self) -> ComposeResult:
        yield Header()
        yield ListView(id="paper-list")
        yield Static(id="status-bar")
        yield Footer()
    
    def on_mount(self) -> None:
        """Initialize the paper list after mounting."""
        self._refresh_list()
        self._update_status()
    
    def _get_filtered_decisions(self) -> list[ReviewDecision]:
        """Get decisions filtered by current filter."""
        if self.current_filter == "all":
            return self.session.decisions
        elif self.current_filter == "kept":
            return self.session.kept_papers
        elif self.current_filter == "discarded":
            return self.session.discarded_papers
        elif self.current_filter == "pending":
            return self.session.pending_papers
        return self.session.decisions
    
    def _refresh_list(self) -> None:
        """Refresh the paper list display."""
        list_view = self.query_one("#paper-list", ListView)
        list_view.clear()
        
        filtered = self._get_filtered_decisions()
        for i, decision in enumerate(filtered):
            list_view.append(PaperListItem(decision, i, self.review_mode))
        
        # Restore selection and focus after UI updates complete.
        # We must reset index to None first, then set desired value.
        # Otherwise, if the index value is unchanged (e.g., still 0),
        # the reactive watcher doesn't fire and highlight isn't updated.
        if filtered:
            target_index = min(self.current_index, len(filtered) - 1)
            list_view.index = None
            list_view.index = target_index
        self.call_later(list_view.focus)
    
    def _update_status(self) -> None:
        """Update the status bar with current counts."""
        kept = len(self.session.kept_papers)
        discarded = len(self.session.discarded_papers)
        pending = len(self.session.pending_papers)
        total = len(self.session.decisions)
        filtered_count = len(self._get_filtered_decisions())
        
        # Build filter indicator
        filter_text = ""
        if self.current_filter != "all":
            filter_text = f" | [yellow]Filter: {self.current_filter} ({filtered_count})[/yellow]"
        
        status = self.query_one("#status-bar", Static)
        if self.review_mode:
            status.update(
                f"Query: {self.session.query} | "
                f"[green]Kept: {kept}[/green] | "
                f"[red]Discarded: {discarded}[/red] | "
                f"Pending: {pending} | "
                f"Total: {total}"
                f"{filter_text}"
            )
        else:
            # Notes mode - simpler status
            status.update(
                f"Papers with notes: {total} | "
                f"Press [bold yellow]n[/bold yellow] to edit notes, "
                f"[bold yellow]p[/bold yellow] to open PDF"
                f"{filter_text}"
            )
    
    def _get_current_decision(self) -> ReviewDecision | None:
        """Get the currently selected decision from filtered list."""
        list_view = self.query_one("#paper-list", ListView)
        filtered = self._get_filtered_decisions()
        if list_view.index is not None and list_view.index < len(filtered):
            self.current_index = list_view.index
            return filtered[list_view.index]
        return None
    
    def action_cursor_down(self) -> None:
        list_view = self.query_one("#paper-list", ListView)
        list_view.action_cursor_down()
    
    def action_cursor_up(self) -> None:
        list_view = self.query_one("#paper-list", ListView)
        list_view.action_cursor_up()
    
    def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle Enter key on ListView - show abstract."""
        self.action_view_abstract()
    
    def action_view_abstract(self) -> None:
        """Show the abstract screen for current paper."""
        decision = self._get_current_decision()
        if decision:
            self.push_screen(
                AbstractScreen(decision, self.session, self.review_mode), 
                self._on_abstract_closed
            )
    
    def _on_abstract_closed(self, result: None) -> None:
        """Called when abstract screen is closed."""
        self._refresh_list()
        self._update_status()
        self.query_one("#paper-list", ListView).focus()
    
    def action_edit_notes(self) -> None:
        """Open editor to edit notes for current paper."""
        decision = self._get_current_decision()
        if decision:
            with self.suspend():
                edit_note_in_editor(decision.paper)
            self._refresh_list()
    
    def action_keep(self) -> None:
        """Quick keep---mark current paper as kept without themes."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        decision = self._get_current_decision()
        if decision:
            decision.status = DecisionStatus.KEPT
            decision.clear_tags()
            self._refresh_list()
            self._update_status()
    
    def action_keep_with_themes(self) -> None:
        """Keep with themes---open theme selection modal."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        decision = self._get_current_decision()
        if decision:
            self.push_screen(
                TagSelectionModal(
                    title=f"Themes: {decision.paper.title[:50]}...",
                    available_tags=list(self.session.all_themes()),
                    tag_counts=self.session.theme_counts(),
                    selected_tags=decision.tags,
                    require_at_least_one=False,
                ),
                self._on_themes_closed,
            )
    
    def _on_themes_closed(self, result: list[str] | None) -> None:
        """Called when theme selection modal is closed."""
        if result is not None:  # None means cancelled
            decision = self._get_current_decision()
            if decision:
                decision.status = DecisionStatus.KEPT
                decision.tags = result
        self._refresh_list()
        self._update_status()
        self.query_one("#paper-list", ListView).focus()
    
    def action_discard(self) -> None:
        """Open motivation selection modal for current paper."""
        if not self.review_mode:
            self.notify("Keep/discard disabled in notes mode", severity="warning")
            return
        decision = self._get_current_decision()
        if decision:
            self.push_screen(
                TagSelectionModal(
                    title=f"Motivations: {decision.paper.title[:50]}...",
                    available_tags=list(self.session.all_motivations()),
                    tag_counts=self.session.motivation_counts(),
                    selected_tags=decision.tags,
                    require_at_least_one=True,
                ),
                self._on_discard_closed,
            )
    
    def _on_discard_closed(self, result: list[str] | None) -> None:
        """Called when motivation selection modal is closed."""
        if result is not None:  # None means cancelled
            decision = self._get_current_decision()
            if decision:
                decision.status = DecisionStatus.DISCARDED
                decision.tags = result
        self._refresh_list()
        self._update_status()
        self.query_one("#paper-list", ListView).focus()
    
    def action_sort(self) -> None:
        """Open sort modal."""
        self.push_screen(SortModal(), self._on_sort_closed)
    
    def _on_sort_closed(self, result: tuple[str, bool] | None) -> None:
        """Called when sort modal is closed."""
        if result:
            key, reverse = result
            self.session.sort_by(key, reverse)
            self._refresh_list()
        self.query_one("#paper-list", ListView).focus()
    
    def action_filter(self) -> None:
        """Open filter modal to select which papers to display.
        
        Filtering helps manage large result sets by focusing on papers with
        a specific status. This is particularly useful when:
        - Resuming a partially completed review (filter to pending)
        - Double-checking kept papers before report generation
        - Reviewing discard motivations for consistency
        """
        self.push_screen(FilterModal(), self._on_filter_closed)
    
    def _on_filter_closed(self, result: str | None) -> None:
        """Apply the selected filter and refresh the display.
        
        When changing filters, we reset to the first item in the filtered list
        to avoid index-out-of-bounds issues and give users a clear starting point.
        """
        if result:
            self.current_filter = result
            self.current_index = 0
            self._refresh_list()
            self._update_status()
        self.query_one("#paper-list", ListView).focus()
@

\section{Report Generation}
\label{sec:report-generation}

After the review session, we generate a \LaTeX\ report documenting the search
parameters, review decisions, motivations, and any notes. This provides an
audit trail for systematic literature reviews.

\subsection{Why \LaTeX\ Output?}

We generate \LaTeX\ (with biblatex) rather than plain text or Markdown because:
\begin{description}
\item[Citation management] Biblatex provides proper bibliographic formatting
  with [[fullcite]] for complete references inline
\item[Academic integration] \LaTeX\ output integrates directly into papers,
  theses, and reports without conversion
\item[Professional formatting] Proper typesetting of titles, authors, and
  structure for formal documentation
\item[Reproducibility] The generated files capture the exact state of the
  review for archival purposes
\end{description}

\subsection{Output Structure}

The generator produces two files with the same base name:
\begin{description}
\item[.tex file] The main document with sections for search parameters,
  summary statistics, kept papers, and discarded papers with motivations
\item[.bib file] BibTeX entries for all reviewed papers, enabling proper
  citations in the \LaTeX\ document
\end{description}

We use [[fullcite]] from biblatex to render complete citations inline,
avoiding the need for a separate bibliography section.

\subsection{Character Escaping}

Both \LaTeX\ and BibTeX have special characters that must be escaped.
We handle these separately because the escaping rules differ:
\begin{itemize}
\item BibTeX: Escape [[&]], [[\%]], [[$]], [[#]], [[_]]
\item \LaTeX: Same plus [[{]], [[}]], [[~]], [[\^{}]], and backslash itself
\end{itemize}

The order of escaping matters: backslashes must be escaped first to avoid
double-escaping the backslashes introduced by other replacements.

Notes are stored as Markdown and converted to \LaTeX\ using pypandoc for proper
rendering in the report.

<<tui report generation>>=
def markdown_to_latex(markdown_text: str) -> str:
    """
    Convert Markdown text to LaTeX using pypandoc.
    
    Falls back to escaped plain text if pypandoc is not available
    or if conversion fails.
    """
    try:
        import pypandoc
        return pypandoc.convert_text(markdown_text, 'latex', format='markdown')
    except Exception:
        # Fallback: escape special characters and return as-is
        return escape_latex(markdown_text)


def generate_latex_report(session: ReviewSession, output_path: Path) -> None:
    """
    Generate a LaTeX report of the review session.
    
    The report includes:
    - Search parameters (query, providers, date)
    - Summary statistics
    - List of kept papers with citations
    - List of discarded papers with motivations
    
    Also generates a .bib file with the same base name.
    """
    def escape_bibtex(text: str) -> str:
        """Escape special BibTeX characters."""
        # BibTeX needs braces around special chars
        text = text.replace('&', r'\&')
        text = text.replace('%', r'\%')
        text = text.replace('$', r'\$')
        text = text.replace('#', r'\#')
        text = text.replace('_', r'\_')
        return text
    
    # escape_latex is imported from scholar.review
    
    def make_cite_key(paper: Paper, index: int) -> str:
        """Generate a unique citation key for a paper."""
        # Use first author's last name + year + index for uniqueness
        if paper.authors:
            first_author = paper.authors[0].split()[-1].lower()
            # Remove non-alphanumeric characters
            first_author = ''.join(c for c in first_author if c.isalnum())
        else:
            first_author = "unknown"
        year = paper.year or "nd"
        return f"{first_author}{year}_{index}"
    
    def format_bibtex_entry(paper: Paper, cite_key: str) -> str:
        """Format a paper as a BibTeX entry."""
        lines = [f"@article{{{cite_key},"]
        lines.append(f"  title = {{{escape_bibtex(paper.title)}}},")
        if paper.authors:
            authors = " and ".join(paper.authors)
            lines.append(f"  author = {{{escape_bibtex(authors)}}},")
        if paper.year:
            lines.append(f"  year = {{{paper.year}}},")
        if paper.venue:
            lines.append(f"  journal = {{{escape_bibtex(paper.venue)}}},")
        if paper.doi:
            lines.append(f"  doi = {{{paper.doi}}},")
        if paper.url:
            lines.append(f"  url = {{{paper.url}}},")
        lines.append("}")
        return "\n".join(lines)
    
    # Generate citation keys for all papers
    all_decisions = session.kept_papers + session.discarded_papers
    cite_keys: dict[int, str] = {}
    for i, decision in enumerate(all_decisions):
        cite_keys[id(decision)] = make_cite_key(decision.paper, i)
    
    # Generate .bib file
    bib_entries = []
    for decision in all_decisions:
        cite_key = cite_keys[id(decision)]
        bib_entries.append(format_bibtex_entry(decision.paper, cite_key))
    
    bib_path = output_path.with_suffix('.bib')
    bib_path.write_text("\n\n".join(bib_entries))
    
    # Generate .tex file with biblatex
    lines = [
        r"\documentclass{article}",
        r"\usepackage[utf8]{inputenc}",
        r"\usepackage{hyperref}",
        r"\usepackage{enumitem}",
        r"\usepackage{geometry}",
        r"\usepackage[backend=biber,style=authoryear]{biblatex}",
        f"\\addbibresource{{{bib_path.name}}}",
        r"\geometry{margin=1in}",
        r"",
        r"\title{Literature Review Report}",
        f"\\date{{{session.timestamp.strftime('%Y-%m-%d')}}}",
        r"",
        r"\begin{document}",
        r"\maketitle",
        r"",
        r"\section{Search Parameters}",
        r"\begin{description}",
        f"\\item[Query] {escape_latex(session.query)}",
        f"\\item[Providers] {', '.join(session.providers)}",
        f"\\item[Date] {session.timestamp.strftime('%Y-%m-%d %H:%M')}",
        f"\\item[Total Papers] {len(session.decisions)}",
        r"\end{description}",
        r"",
        r"\section{Summary}",
        r"\begin{description}",
        f"\\item[Kept] {len(session.kept_papers)}",
        f"\\item[Discarded] {len(session.discarded_papers)}",
        f"\\item[Pending] {len(session.pending_papers)}",
        r"\end{description}",
        r"",
    ]
    
    # Kept papers section
    if session.kept_papers:
        lines.extend([
            r"\section{Kept Papers}",
            r"\begin{enumerate}",
        ])
        for decision in session.kept_papers:
            cite_key = cite_keys[id(decision)]
            lines.append(f"\\item \\fullcite{{{cite_key}}}")
        lines.append(r"\end{enumerate}")
        lines.append("")
    
    # Discarded papers section
    if session.discarded_papers:
        lines.extend([
            r"\section{Discarded Papers}",
            r"\begin{enumerate}",
        ])
        for decision in session.discarded_papers:
            cite_key = cite_keys[id(decision)]
            motivation = escape_latex(decision.motivation)
            lines.append(f"\\item \\fullcite{{{cite_key}}}")
            lines.append(f"  \\\\\\textbf{{Motivation:}} {motivation}")
        lines.append(r"\end{enumerate}")
        lines.append("")
    
    lines.extend([
        r"\end{document}",
    ])
    
    output_path.write_text("\n".join(lines))


def prompt_for_report(session: ReviewSession) -> None:
    """
    Prompt the user to save a LaTeX report after the review session.
    
    Called after the TUI exits if any decisions were made.
    """
    from rich.prompt import Prompt, Confirm
    from rich.console import Console
    
    console = Console()
    
    kept = len(session.kept_papers)
    discarded = len(session.discarded_papers)
    
    if kept == 0 and discarded == 0:
        return
    
    console.print(f"\n[bold]Review session complete![/bold]")
    console.print(f"  [green]Kept:[/green] {kept}")
    console.print(f"  [red]Discarded:[/red] {discarded}")
    console.print(f"  Pending: {len(session.pending_papers)}")
    
    if Confirm.ask("\nWould you like to save a LaTeX report?", default=True):
        default_name = f"review_{session.timestamp.strftime('%Y%m%d_%H%M%S')}.tex"
        filename = Prompt.ask("Filename", default=default_name)
        output_path = Path(filename)
        generate_latex_report(session, output_path)
        console.print(f"[green]Report saved to {output_path}[/green]")
@

\subsection{Testing report generation}

Let's verify that the LaTeX report generation works correctly and properly
escapes special characters.

<<test functions>>=
class TestLatexReport:
    """Tests for LaTeX report generation."""

    def test_generate_report(self, tmp_path):
        """Test basic report generation.

        The generator creates both a .tex file (with fullcite references)
        and a .bib file (with paper details). We check both files.
        """
        paper = Paper(
            title="Test Paper",
            authors=["John Doe", "Jane Smith"],
            year=2024,
            doi="10.1234/test",
            venue="Test Conference",
        )
        session = ReviewSession(
            query="machine learning",
            providers=["semantic_scholar"],
            timestamp=datetime(2024, 1, 15, 10, 30),
        )
        session.decisions = [
            ReviewDecision(paper=paper, provider="semantic_scholar", status=DecisionStatus.KEPT),
        ]

        output_path = tmp_path / "report.tex"
        generate_latex_report(session, output_path)

        # Check .tex file for report structure
        tex_content = output_path.read_text()
        assert r"\title{Literature Review Report}" in tex_content
        assert "machine learning" in tex_content
        assert r"\fullcite{" in tex_content

        # Check .bib file for paper details
        bib_path = output_path.with_suffix(".bib")
        bib_content = bib_path.read_text()
        assert "Test Paper" in bib_content
        assert "John Doe" in bib_content
        assert "2024" in bib_content

    def test_escapes_special_characters(self, tmp_path):
        """Test that special BibTeX characters are escaped in .bib file."""
        paper = Paper(
            title="Test & Paper with 100% special_chars",
            authors=["O'Brien"],
            year=2024,
        )
        session = ReviewSession(
            query="test",
            providers=["test"],
            timestamp=datetime.now(),
        )
        session.decisions = [
            ReviewDecision(paper=paper, provider="test", status=DecisionStatus.KEPT),
        ]

        output_path = tmp_path / "report.tex"
        generate_latex_report(session, output_path)

        # Special characters should be escaped in the .bib file
        bib_path = output_path.with_suffix(".bib")
        bib_content = bib_path.read_text()
        assert r"\&" in bib_content
        assert r"\%" in bib_content
        assert r"\_" in bib_content
@


\section{Entry Point}
\label{sec:entry-point}

The main entry point creates a review session from search results and launches
the TUI application.

\subsection{Session Reconstruction}

A key feature is the ability to resume interrupted review sessions. When a user
runs the same query again (or uses a named session), we:
\begin{enumerate}
\item Load previously saved decisions from [[notes.py]] storage
\item Match papers by ID (DOI or title hash) to restore their status
\item Merge any new papers from the current search with existing decisions
\item Preserve papers from previous sessions even if not in current results
\end{enumerate}

This merging behavior supports iterative workflows: a reviewer might run
multiple related queries over time, accumulating papers into a single
named session.

\subsection{Two Operating Modes}

The entry point supports two distinct modes:
\begin{description}
\item[Review mode] ([[run_review]]) For reviewing search results with
  keep/discard functionality. Decisions are persisted and reports generated.
\item[Notes mode] ([[run_notes_browser]]) For browsing papers that have notes
  attached, without keep/discard. Useful for revisiting annotated papers.
\end{description}

<<tui entry point>>=
def run_review(results: list[SearchResult], query: str, 
               session_name: str | None = None) -> ReviewSession:
    """
    Run the interactive review TUI for search results.
    
    Converts SearchResult objects into a ReviewSession, launches the TUI,
    and returns the session with all decisions after the user exits.
    
    Args:
        results: Search results to review
        query: The search query (for display)
        session_name: Name for decision persistence. If provided, decisions are
                      stored under this name instead of the query. This allows
                      the same query with different names (different purposes)
                      or multiple queries with the same name (appending results).
    """
    # Use session_name for persistence, fall back to query
    persistence_key = session_name if session_name else query
    
    # Create review session using the review module
    session = create_review_session(results, query, session_name)
    
    # Run the TUI in review mode
    app = PaperReviewApp(session, review_mode=True)
    app.run()
    
    # Save decisions for this session
    save_search_decisions(persistence_key, session.decisions)
    
    # Prompt for report
    prompt_for_report(session)
    
    return session


def run_notes_browser() -> None:
    """
    Run the notes browser TUI for viewing and editing paper notes.
    
    This launches the TUI in notes-only mode (no keep/discard functionality),
    showing all papers that have notes attached.
    """
    from scholar.review import create_notes_session
    
    session = create_notes_session()
    
    if not session.decisions:
        console = Console()
        console.print("[yellow]No papers with notes found.[/yellow]")
        console.print("Use 'scholar search --review' to review papers and add notes.")
        return
    
    # Run the TUI in notes-only mode (no keep/discard)
    app = PaperReviewApp(session, review_mode=False)
    app.run()
@
