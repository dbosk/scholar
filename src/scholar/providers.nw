\input{preamble.tex}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}

This module implements search providers---adapters that connect Scholar to
various bibliographic databases.
Each provider knows how to query a specific database and convert results to
our common [[Paper]] type.

The provider abstraction allows us to:
\begin{description}
\item[Add new databases] without modifying the core search logic.
\item[Test in isolation] by mocking individual providers.
\item[Configure per-provider] settings like API keys and rate limits.
\end{description}


\section{Module structure}

The providers module exports the provider protocol and registry functions:

<<[[providers.py]]>>=
"""
Search providers for bibliographic databases.

Each provider implements the SearchProvider protocol and registers
itself with the provider registry on import.
"""

<<imports>>
<<constants>>
<<provider protocol>>
<<provider registry>>
<<semantic scholar provider>>
<<openalex provider>>
<<dblp provider>>
<<wos provider>>
@


\chapter{Provider Protocol}

We define a protocol (structural typing) rather than an abstract base class.
This allows providers to be implemented without inheritance, which is more
Pythonic and easier to test.

A provider must have:
\begin{description}
\item[name] A unique identifier string.
\item[search] A method that takes a query and returns papers.
\end{description}

<<provider protocol>>=
class SearchProvider(Protocol):
    """Protocol for search providers."""

    name: str

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """
        Search for papers matching the query.

        Args:
            query: The search query string.
            limit: Maximum number of results to return.

        Returns:
            List of Paper objects matching the query.
        """
        ...
@


\chapter{Provider Registry}

Providers register themselves when imported.
This allows the [[Search]] class to discover available providers without
hardcoding them.

<<provider registry>>=
PROVIDERS: dict[str, SearchProvider] = {}


def register_provider(provider: SearchProvider) -> None:
    """Register a provider for use in searches."""
    PROVIDERS[provider.name] = provider


def get_provider(name: str) -> SearchProvider | None:
    """Get a provider by name, or None if not found."""
    return PROVIDERS.get(name)


def get_all_providers() -> list[SearchProvider]:
    """Get all registered providers."""
    return list(PROVIDERS.values())
@


\chapter{Semantic Scholar Provider}

Semantic Scholar is an AI-powered research tool that provides free access to
over 200 million academic papers.
Their API allows searching papers by keyword, author, venue, and more.

We use the [[semanticscholar]] Python package which handles API communication,
rate limiting, and pagination.

\section{Provider implementation}

<<semantic scholar provider>>=
class SemanticScholarProvider:
    """Search provider for Semantic Scholar."""

    name = "semantic_scholar"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Semantic Scholar provider.

        Args:
            api_key: Optional API key for higher rate limits.
                     If not provided, uses S2_API_KEY environment variable.
        """
        self.client = SemanticScholar(api_key=api_key)

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search Semantic Scholar for papers matching the query."""
        try:
            results = self.client.search_paper(
                query,
                limit=limit,
                fields=[
                    "title",
                    "authors",
                    "year",
                    "abstract",
                    "venue",
                    "externalIds",
                    "url",
                ],
            )
            return [self._convert_paper(p) for p in results]
        except Exception:
            # Return empty list on API errors
            return []

    <<convert semantic scholar paper>>
@

\subsection{Converting paper format}

Semantic Scholar returns papers in their own format.
We convert them to our common [[Paper]] type:

<<convert semantic scholar paper>>=
def _convert_paper(self, ss_paper) -> Paper:
    """Convert a Semantic Scholar paper to our Paper type."""
    # Extract DOI from externalIds if available
    doi = None
    if ss_paper.externalIds:
        doi = ss_paper.externalIds.get("DOI")

    # Extract author names
    authors = []
    if ss_paper.authors:
        authors = [a.name for a in ss_paper.authors if a.name]

    return Paper(
        title=ss_paper.title or "",
        authors=authors,
        year=ss_paper.year,
        doi=doi,
        abstract=ss_paper.abstract,
        venue=ss_paper.venue,
        url=ss_paper.url,
        source=self.name,
    )
@

\section{Auto-registration}

We register the provider when this module is imported:

<<semantic scholar provider>>=
# Register the provider on module import
register_provider(SemanticScholarProvider())
@

\section{Dependencies}

<<semantic scholar imports>>=
from semanticscholar import SemanticScholar
@


\chapter{OpenAlex Provider}

OpenAlex is a free and open catalog of the world's scholarly works, authors,
venues, institutions, and concepts.
It covers over 250 million works and is fully open access.

We use the [[pyalex]] Python package which provides a clean interface to the
OpenAlex API.
No API key is required, though providing an email address gives access to the
\enquote{polite pool} with faster response times.

\section{Provider implementation}

<<openalex provider>>=
class OpenAlexProvider:
    """Search provider for OpenAlex."""

    name = "openalex"

    def __init__(self, email: str | None = None):
        """
        Initialize the OpenAlex provider.

        Args:
            email: Optional email for polite pool access (faster responses).
                   If not provided, uses OPENALEX_EMAIL environment variable.
        """
        configured_email = email or os.environ.get("OPENALEX_EMAIL")
        if configured_email:
            pyalex.config.email = configured_email

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search OpenAlex for papers matching the query."""
        try:
            works = pyalex.Works().search(query).get(per_page=limit)
            return [self._convert_work(w) for w in works]
        except Exception:
            return []

    <<convert openalex work>>
@

\subsection{Converting work format}

OpenAlex returns works as dictionaries.
We extract the relevant fields and convert to our [[Paper]] type:

<<convert openalex work>>=
def _convert_work(self, work: dict) -> Paper:
    """Convert an OpenAlex work to our Paper type."""
    # Extract author names from authorships
    authors = []
    for authorship in work.get("authorships", []):
        author_info = authorship.get("author", {})
        name = author_info.get("display_name")
        if name:
            authors.append(name)

    # Extract DOI (remove URL prefix if present)
    doi = work.get("doi")
    if doi and doi.startswith("https://doi.org/"):
        doi = doi[16:]

    # Extract venue from primary location
    venue = None
    primary_location = work.get("primary_location", {})
    if primary_location:
        source = primary_location.get("source", {})
        if source:
            venue = source.get("display_name")

    return Paper(
        title=work.get("title", ""),
        authors=authors,
        year=work.get("publication_year"),
        doi=doi,
        abstract=work.get("abstract"),
        venue=venue,
        url=work.get("id"),
        source=self.name,
    )
@

\section{Auto-registration}

<<openalex provider>>=
# Register the provider on module import
register_provider(OpenAlexProvider())
@

\section{Dependencies}

<<openalex imports>>=
import pyalex
@


\chapter{DBLP Provider}

DBLP is a computer science bibliography database hosted at the University of
Trier and Schloss Dagstuhl.
It provides comprehensive coverage of major computer science journals and
conference proceedings.

\section{Package evaluation}

We evaluated several Python packages for DBLP access:

\begin{description}
\item[dblpy-lib (0.1.3)] Appeared well-maintained with a clean API
  ([[get_publications(q, max_results)]]).
  However, it requires [[requests>=2.27.1,<2.28.0]], which conflicts with our
  [[requests^2.31]] dependency.
\item[dblp (0.1.0)] Returns pandas DataFrames, which seemed convenient.
  However, it fails to install due to a bug in its setup script---it passes a
  list where a string is expected ([[TypeError: expected string or bytes-like
  object, got 'list']]).
\end{description}

Given these issues, we use the DBLP public API directly via [[requests]], which
we already depend on.
No API key is required.
The API returns JSON with publication data that we parse directly.

\section{Provider implementation}

<<dblp provider>>=
class DBLPProvider:
    """Search provider for DBLP."""

    name = "dblp"

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search DBLP for papers matching the query."""
        try:
            # DBLP API caps at 1000 results per request
            effective_limit = min(limit, 1000)
            response = requests.get(
                DBLP_API_URL,
                params={"q": query, "format": "json", "h": effective_limit},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("result", {}).get("hits", {}).get("hit", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception:
            return []

    <<convert dblp hit>>
@

\subsection{Converting publication format}

The DBLP API returns each publication as a JSON object with an [[info]] field
containing:
\begin{description}
\item[authors] Object with [[author]] array, each having a [[text]] field.
\item[title] The publication title.
\item[venue] The venue (conference or journal).
\item[year] Publication year as string.
\item[doi] The DOI (if available).
\item[ee] Electronic edition URL.
\item[url] URL to the DBLP record.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert dblp hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a DBLP API hit to our Paper type."""
    info = hit.get("info", {})

    # Extract year as integer if available
    year = None
    year_str = info.get("year")
    if year_str:
        try:
            year = int(year_str)
        except (ValueError, TypeError):
            pass

    # Extract author names from nested structure
    authors = []
    authors_data = info.get("authors", {}).get("author", [])
    # Handle single author (dict) vs multiple authors (list)
    if isinstance(authors_data, dict):
        authors_data = [authors_data]
    for author in authors_data:
        name = author.get("text") if isinstance(author, dict) else author
        if name:
            authors.append(name)

    return Paper(
        title=info.get("title", "") or "",
        authors=authors,
        year=year,
        doi=info.get("doi"),
        abstract=None,  # DBLP doesn't provide abstracts
        venue=info.get("venue"),
        url=info.get("url") or info.get("ee"),
        source=self.name,
    )
@

\section{Auto-registration}

<<dblp provider>>=
# Register the provider on module import
register_provider(DBLPProvider())
@

\section{Dependencies}

<<dblp imports>>=
import requests
@

<<dblp constants>>=
DBLP_API_URL = "https://dblp.org/search/publ/api"
@


\chapter{Web of Science Provider}

Web of Science (WoS) is a comprehensive citation index covering scholarly
literature across sciences, social sciences, arts, and humanities.
It is maintained by Clarivate and requires institutional access or an API key.

\section{API options}

Clarivate provides several API options:

\begin{description}
\item[Web of Science API Expanded] Full access with advanced features.
  Requires institutional subscription.
\item[Web of Science Starter API] Basic search with bibliographic metadata.
  Has a free tier (50 requests/day) and institutional tiers (5,000--20,000
  requests/day).
\end{description}

The official Python client ([[wosstarter_python_client]]) is only available
from GitHub, not PyPI.
For consistency with our DBLP implementation, we use the Starter API's REST
endpoint directly via [[requests]].

\section{Provider implementation}

<<wos provider>>=
class WebOfScienceProvider:
    """Search provider for Web of Science."""

    name = "wos"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Web of Science provider.

        Args:
            api_key: API key for WoS Starter API.
                     If not provided, uses WOS_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("WOS_API_KEY")

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search Web of Science for papers matching the query."""
        if not self.api_key:
            return []  # No API key configured

        try:
            # WoS Starter API has max 50 results per page
            effective_limit = min(limit, 50)
            response = requests.get(
                WOS_API_URL,
                params={
                    "q": query,
                    "db": "WOS",
                    "limit": effective_limit,
                    "page": 1,
                },
                headers={"X-ApiKey": self.api_key},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("hits", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception:
            return []

    <<convert wos hit>>
@

\subsection{Converting document format}

The WoS Starter API returns documents with fields including:
\begin{description}
\item[uid] Unique WoS identifier.
\item[title] The document title.
\item[names] Object with [[authors]] array containing author names.
\item[source] Source publication information including [[sourceTitle]].
\item[links] Object with [[record]] URL to WoS page.
\item[identifiers] Object with DOI and other identifiers.
\item[keywords] Object with [[authorKeywords]] array.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert wos hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a WoS API hit to our Paper type."""
    # Extract publication year from source
    source = hit.get("source", {})
    year = None
    pub_year = source.get("publishYear")
    if pub_year:
        try:
            year = int(pub_year)
        except (ValueError, TypeError):
            pass

    # Extract author names
    authors = []
    names = hit.get("names", {})
    for author in names.get("authors", []):
        name = author.get("displayName")
        if name:
            authors.append(name)

    # Extract DOI from identifiers
    doi = None
    identifiers = hit.get("identifiers", {})
    doi = identifiers.get("doi")

    # Extract URL from links
    url = None
    links = hit.get("links", {})
    url = links.get("record")

    return Paper(
        title=hit.get("title", "") or "",
        authors=authors,
        year=year,
        doi=doi,
        abstract=None,  # Not available in Starter API
        venue=source.get("sourceTitle"),
        url=url,
        source=self.name,
    )
@

\section{Auto-registration}

<<wos provider>>=
# Register the provider on module import
register_provider(WebOfScienceProvider())
@

\section{Dependencies}

Since the provider uses the same [[requests]] library as DBLP, we only need
to define the API URL constant:

<<wos constants>>=
WOS_API_URL = "https://api.clarivate.com/apis/wos-starter/v1/documents"
@


\chapter{Dependencies}

We organize imports so each provider's dependencies are co-located with
its implementation.
If a provider is removed, its dependencies go with it.

<<imports>>=
import os
from typing import Protocol

from scholar import Paper
<<semantic scholar imports>>
<<openalex imports>>
<<dblp imports>>
@

<<constants>>=
# Provider constants
DEFAULT_LIMIT = 100
<<dblp constants>>
<<wos constants>>
@


\chapter{Testing}
\label{ch:providers-testing}

We test both the registry and the Semantic Scholar provider.

<<test [[providers.py]]>>=
"""Tests for the providers module."""
import pytest
from unittest.mock import Mock, patch

from scholar import Paper
from scholar.providers import (
    SemanticScholarProvider,
    OpenAlexProvider,
    DBLPProvider,
    WebOfScienceProvider,
    register_provider,
    get_provider,
    get_all_providers,
    PROVIDERS,
)
@


\section{Testing the registry}

The registry should store and retrieve providers:

<<test [[providers.py]]>>=
class TestProviderRegistry:
    """Tests for the provider registry."""

    def test_semantic_scholar_registered(self):
        """Semantic Scholar provider is auto-registered."""
        provider = get_provider("semantic_scholar")
        assert provider is not None
        assert provider.name == "semantic_scholar"

    def test_openalex_registered(self):
        """OpenAlex provider is auto-registered."""
        provider = get_provider("openalex")
        assert provider is not None
        assert provider.name == "openalex"

    def test_dblp_registered(self):
        """DBLP provider is auto-registered."""
        provider = get_provider("dblp")
        assert provider is not None
        assert provider.name == "dblp"

    def test_wos_registered(self):
        """Web of Science provider is auto-registered."""
        provider = get_provider("wos")
        assert provider is not None
        assert provider.name == "wos"

    def test_get_all_providers(self):
        """get_all_providers returns registered providers."""
        providers = get_all_providers()
        assert len(providers) >= 4
        names = [p.name for p in providers]
        assert "semantic_scholar" in names
        assert "openalex" in names
        assert "dblp" in names
        assert "wos" in names

    def test_get_unknown_provider(self):
        """get_provider returns None for unknown providers."""
        assert get_provider("unknown_provider") is None
@


\section{Testing Semantic Scholar provider}

We mock the API client to avoid real network calls in tests:

<<test [[providers.py]]>>=
class TestSemanticScholarProvider:
    """Tests for the SemanticScholar provider."""

    def test_search_converts_papers(self):
        """search() converts API results to Paper objects."""
        provider = SemanticScholarProvider()

        # Create mock paper
        mock_paper = Mock()
        mock_paper.title = "Test Paper"
        mock_paper.authors = [Mock(name="Alice"), Mock(name="Bob")]
        mock_paper.year = 2024
        mock_paper.externalIds = {"DOI": "10.1234/test"}
        mock_paper.abstract = "Test abstract"
        mock_paper.venue = "Test Conference"
        mock_paper.url = "https://example.com/paper"

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.return_value = [mock_paper]

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.source == "semantic_scholar"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = SemanticScholarProvider()

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.return_value = []

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = SemanticScholarProvider()

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []
@


\section{Integration test}

We include a single integration test that makes one real API call to verify
the provider works with the actual Semantic Scholar API.
This test is marked with \texttt{@pytest.mark.integration} and skipped by
default because Semantic Scholar has strict rate limits.

To run integration tests explicitly:
\begin{verbatim}
pytest -m integration
\end{verbatim}

<<test [[providers.py]]>>=
class TestSemanticScholarIntegration:
    """Integration test for the SemanticScholar provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default due to API rate limits")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        from semanticscholar import SemanticScholar

        # Call the API directly to see any errors (not through our wrapper)
        client = SemanticScholar()
        try:
            results = client.search_paper(
                "machine learning",
                limit=1,
                fields=["title", "authors", "year"],
            )
            results_list = list(results)

            # If API works, verify we get results
            assert len(results_list) >= 1, "API returned no results"

            # Verify the provider wrapper also works
            provider = SemanticScholarProvider()
            papers = provider.search("machine learning", limit=1)
            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "semantic_scholar"
        except Exception as e:
            pytest.skip(f"Semantic Scholar API unavailable: {e}")
@


\section{Testing OpenAlex provider}

We test the OpenAlex provider with mocked API responses:

<<test [[providers.py]]>>=
class TestOpenAlexProvider:
    """Tests for the OpenAlex provider."""

    def test_search_converts_works(self):
        """search() converts API results to Paper objects."""
        provider = OpenAlexProvider()

        # Create mock work (OpenAlex returns dicts)
        mock_work = {
            "title": "Test Paper",
            "authorships": [
                {"author": {"display_name": "Alice"}},
                {"author": {"display_name": "Bob"}},
            ],
            "publication_year": 2024,
            "doi": "https://doi.org/10.1234/test",
            "abstract": "Test abstract",
            "primary_location": {
                "source": {"display_name": "Test Journal"}
            },
            "id": "https://openalex.org/W123456",
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Test Journal"
            assert paper.source == "openalex"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = []

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles works with missing optional fields."""
        provider = OpenAlexProvider()

        # Minimal work with only required fields
        mock_work = {
            "title": "Minimal Paper",
            "authorships": [],
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
@


<<test [[providers.py]]>>=
class TestOpenAlexIntegration:
    """Integration test for the OpenAlex provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = OpenAlexProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "openalex"
        except Exception as e:
            pytest.skip(f"OpenAlex API unavailable: {e}")
@


\section{Testing DBLP provider}

We test the DBLP provider with mocked API responses:

<<test [[providers.py]]>>=
class TestDBLPProvider:
    """Tests for the DBLP provider."""

    def test_search_converts_publications(self):
        """search() converts API results to Paper objects."""
        provider = DBLPProvider()

        # Create mock API response (DBLP returns JSON)
        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Test Paper",
                            "authors": {
                                "author": [
                                    {"text": "Alice"},
                                    {"text": "Bob"},
                                ]
                            },
                            "year": "2024",
                            "venue": "ICSE",
                            "doi": "10.1234/test",
                            "url": "https://dblp.org/rec/conf/icse/Test24",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "ICSE"
            assert paper.source == "dblp"

    def test_search_handles_single_author(self):
        """search() handles single author as dict instead of list."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Solo Paper",
                            "authors": {"author": {"text": "Solo Author"}},
                            "year": "2024",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            assert results[0].authors == ["Solo Author"]

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {"hits": {"hit": []}}
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = DBLPProvider()

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles publications with missing optional fields."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {"title": "Minimal Paper"}
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_respects_limit_parameter(self):
        """search() passes limit to API."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=50)

            mock_get.assert_called_once()
            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 50

    def test_caps_limit_at_1000(self):
        """search() caps limit at DBLP's maximum of 1000."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=2000)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 1000
@


<<test [[providers.py]]>>=
class TestDBLPIntegration:
    """Integration test for the DBLP provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = DBLPProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "dblp"
        except Exception as e:
            pytest.skip(f"DBLP API unavailable: {e}")
@


\section{Testing Web of Science provider}

We test the WoS provider with mocked API responses.
Note that without an API key, the provider returns empty results:

<<test [[providers.py]]>>=
class TestWebOfScienceProvider:
    """Tests for the Web of Science provider."""

    def test_search_returns_empty_without_api_key(self):
        """search() returns empty list when no API key is configured."""
        provider = WebOfScienceProvider(api_key=None)
        results = provider.search("test")
        assert results == []

    def test_search_converts_documents(self):
        """search() converts API results to Paper objects."""
        provider = WebOfScienceProvider(api_key="test_key")

        # Create mock API response
        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{
                "title": "Test Paper",
                "names": {
                    "authors": [
                        {"displayName": "Alice Smith"},
                        {"displayName": "Bob Jones"},
                    ]
                },
                "source": {
                    "sourceTitle": "Nature",
                    "publishYear": "2024",
                },
                "identifiers": {"doi": "10.1234/test"},
                "links": {"record": "https://wos.com/record/123"},
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice Smith", "Bob Jones"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Nature"
            assert paper.source == "wos"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = WebOfScienceProvider(api_key="test_key")

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles documents with missing optional fields."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{"title": "Minimal Paper"}]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_caps_limit_at_50(self):
        """search() caps limit at WoS Starter API's maximum of 50."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=100)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["limit"] == 50

    def test_sends_api_key_header(self):
        """search() sends API key in header."""
        provider = WebOfScienceProvider(api_key="my_secret_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test")

            call_args = mock_get.call_args
            assert call_args[1]["headers"]["X-ApiKey"] == "my_secret_key"
@


<<test [[providers.py]]>>=
class TestWebOfScienceIntegration:
    """Integration test for the Web of Science provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default; requires WOS_API_KEY")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        import os

        api_key = os.environ.get("WOS_API_KEY")
        if not api_key:
            pytest.skip("WOS_API_KEY environment variable not set")

        provider = WebOfScienceProvider(api_key=api_key)

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "wos"
        except Exception as e:
            pytest.skip(f"Web of Science API unavailable: {e}")
@


\end{document}
