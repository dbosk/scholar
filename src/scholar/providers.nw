\chapter{Search Providers}
\label{providers-module}

\section{Introduction}

This module implements search providers---adapters that connect Scholar to
various bibliographic databases.
Each provider knows how to query a specific database and convert results to
our common [[Paper]] type.

The provider abstraction allows us to:
\begin{description}
\item[Add new databases] without modifying the core search logic.
\item[Test in isolation] by mocking individual providers.
\item[Configure per-provider] settings like API keys and rate limits.
\item[Cache results] to avoid redundant API calls and respect rate limits.
\end{description}

\section{Caching}

Each provider caches search results using [[cachetools]].
The cache is a plain dictionary keyed by the query and limit parameters.
Caches are persisted to disk using pickle, so results survive across program
runs.
This is particularly useful for systematic reviews where the same search may
be run multiple times.


\section{Module structure}

The providers module exports the provider protocol and registry functions:

<<[[providers.py]]>>=
"""
Search providers for bibliographic databases.

Each provider implements the SearchProvider protocol and registers
itself with the provider registry on import.
"""

<<imports>>
<<constants>>
<<provider protocol>>
<<provider registry>>
<<semantic scholar provider>>
<<openalex provider>>
<<dblp provider>>
<<wos provider>>
<<ieee provider>>
@


\chapter{Provider Protocol}

We define a protocol (structural typing) rather than an abstract base class.
This allows providers to be implemented without inheritance, which is more
Pythonic and easier to test.

A provider must have:
\begin{description}
\item[name] A unique identifier string.
\item[search] A method that takes a query and returns papers.
\end{description}

<<provider protocol>>=
class SearchProvider(Protocol):
    """Protocol for search providers."""

    name: str

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """
        Search for papers matching the query.

        Args:
            query: The search query string.
            limit: Maximum number of results to return.

        Returns:
            List of Paper objects matching the query.
        """
        ...
@


\chapter{Provider Registry}

Providers register themselves when imported.
This allows the [[Search]] class to discover available providers without
hardcoding them.

<<provider registry>>=
PROVIDERS: dict[str, SearchProvider] = {}


def register_provider(provider: SearchProvider) -> None:
    """Register a provider for use in searches."""
    PROVIDERS[provider.name] = provider


def get_provider(name: str) -> SearchProvider | None:
    """Get a provider by name, or None if not found."""
    return PROVIDERS.get(name)


def get_all_providers() -> list[SearchProvider]:
    """Get all registered providers."""
    return list(PROVIDERS.values())
@


\chapter{Semantic Scholar Provider}

Semantic Scholar is an AI-powered research tool that provides free access to
over 200 million academic papers.
Their API allows searching papers by keyword, author, venue, and more.

We use the [[semanticscholar]] Python package which handles API communication,
rate limiting, and pagination.

\section{Provider implementation}

<<semantic scholar provider>>=
class SemanticScholarProvider:
    """Search provider for Semantic Scholar."""

    name = "semantic_scholar"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Semantic Scholar provider.

        Args:
            api_key: Optional API key for higher rate limits.
                     If not provided, uses S2_API_KEY environment variable.
        """
        self.client = SemanticScholar(api_key=api_key)
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search Semantic Scholar for papers matching the query."""
        try:
            results = self.client.search_paper(
                query,
                limit=limit,
                fields=[
                    "title",
                    "authors",
                    "year",
                    "abstract",
                    "venue",
                    "externalIds",
                    "url",
                ],
            )
            return [self._convert_paper(p) for p in results]
        except Exception:
            # Return empty list on API errors
            return []

    <<convert semantic scholar paper>>
@

\subsection{Converting paper format}

Semantic Scholar returns papers in their own format.
We convert them to our common [[Paper]] type:

<<convert semantic scholar paper>>=
def _convert_paper(self, ss_paper) -> Paper:
    """Convert a Semantic Scholar paper to our Paper type."""
    # Extract DOI from externalIds if available
    doi = None
    if ss_paper.externalIds:
        doi = ss_paper.externalIds.get("DOI")

    # Extract author names
    authors = []
    if ss_paper.authors:
        authors = [a.name for a in ss_paper.authors if a.name]

    return Paper(
        title=ss_paper.title or "",
        authors=authors,
        year=ss_paper.year,
        doi=doi,
        abstract=ss_paper.abstract,
        venue=ss_paper.venue,
        url=ss_paper.url,
        source=self.name,
    )
@

\section{Auto-registration}

We register the provider when this module is imported:

<<semantic scholar provider>>=
# Register the provider on module import
register_provider(SemanticScholarProvider())
@

\section{Dependencies}

<<semantic scholar imports>>=
from semanticscholar import SemanticScholar
@

\section{Testing Semantic Scholar provider}

We mock the API client to avoid real network calls in tests:

<<test semantic scholar>>=
class TestSemanticScholarProvider:
    """Tests for the SemanticScholar provider."""

    def test_search_converts_papers(self):
        """search() converts API results to Paper objects."""
        provider = SemanticScholarProvider()

        # Create mock paper
        mock_paper = Mock()
        mock_paper.title = "Test Paper"
        mock_paper.authors = [Mock(name="Alice"), Mock(name="Bob")]
        mock_paper.year = 2024
        mock_paper.externalIds = {"DOI": "10.1234/test"}
        mock_paper.abstract = "Test abstract"
        mock_paper.venue = "Test Conference"
        mock_paper.url = "https://example.com/paper"

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.return_value = [mock_paper]

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.source == "semantic_scholar"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = SemanticScholarProvider()

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.return_value = []

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = SemanticScholarProvider()

        with patch.object(provider.client, "search_paper") as mock_search:
            mock_search.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []


class TestSemanticScholarIntegration:
    """Integration test for the SemanticScholar provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default due to API rate limits")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        from semanticscholar import SemanticScholar

        # Call the API directly to see any errors (not through our wrapper)
        client = SemanticScholar()
        try:
            results = client.search_paper(
                "machine learning",
                limit=1,
                fields=["title", "authors", "year"],
            )
            results_list = list(results)

            # If API works, verify we get results
            assert len(results_list) >= 1, "API returned no results"

            # Verify the provider wrapper also works
            provider = SemanticScholarProvider()
            papers = provider.search("machine learning", limit=1)
            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "semantic_scholar"
        except Exception as e:
            pytest.skip(f"Semantic Scholar API unavailable: {e}")
@


\chapter{OpenAlex Provider}

OpenAlex is a free and open catalog of the world's scholarly works, authors,
venues, institutions, and concepts.
It covers over 250 million works and is fully open access.

We use the [[pyalex]] Python package which provides a clean interface to the
OpenAlex API.
No API key is required, though providing an email address gives access to the
\enquote{polite pool} with faster response times.

\section{Provider implementation}

<<openalex provider>>=
class OpenAlexProvider:
    """Search provider for OpenAlex."""

    name = "openalex"

    def __init__(self, email: str | None = None):
        """
        Initialize the OpenAlex provider.

        Args:
            email: Optional email for polite pool access (faster responses).
                   If not provided, uses OPENALEX_EMAIL environment variable.
        """
        configured_email = email or os.environ.get("OPENALEX_EMAIL")
        if configured_email:
            pyalex.config.email = configured_email
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search OpenAlex for papers matching the query."""
        try:
            works = pyalex.Works().search(query).get(per_page=limit)
            return [self._convert_work(w) for w in works]
        except Exception:
            return []

    <<convert openalex work>>
@

\subsection{Converting work format}

OpenAlex returns works as dictionaries.
We extract the relevant fields and convert to our [[Paper]] type:

<<convert openalex work>>=
def _convert_work(self, work: dict) -> Paper:
    """Convert an OpenAlex work to our Paper type."""
    # Extract author names from authorships
    authors = []
    for authorship in work.get("authorships", []):
        author_info = authorship.get("author", {})
        name = author_info.get("display_name")
        if name:
            authors.append(name)

    # Extract DOI (remove URL prefix if present)
    doi = work.get("doi")
    if doi and doi.startswith("https://doi.org/"):
        doi = doi[16:]

    # Extract venue from primary location
    venue = None
    primary_location = work.get("primary_location", {})
    if primary_location:
        source = primary_location.get("source", {})
        if source:
            venue = source.get("display_name")

    # Extract PDF URL from open_access or primary_location
    pdf_url = None
    open_access = work.get("open_access", {})
    if open_access:
        pdf_url = open_access.get("oa_url")
    if not pdf_url and primary_location:
        pdf_url = primary_location.get("pdf_url")

    return Paper(
        title=work.get("title", ""),
        authors=authors,
        year=work.get("publication_year"),
        doi=doi,
        abstract=work.get("abstract"),
        venue=venue,
        url=work.get("id"),
        pdf_url=pdf_url,
        source=self.name,
    )
@

\section{Auto-registration}

<<openalex provider>>=
# Register the provider on module import
register_provider(OpenAlexProvider())
@

\section{Dependencies}

<<openalex imports>>=
import pyalex
@

\section{Testing OpenAlex provider}

We test the OpenAlex provider with mocked API responses:

<<test openalex>>=
class TestOpenAlexProvider:
    """Tests for the OpenAlex provider."""

    def test_search_converts_works(self):
        """search() converts API results to Paper objects."""
        provider = OpenAlexProvider()

        # Create mock work (OpenAlex returns dicts)
        mock_work = {
            "title": "Test Paper",
            "authorships": [
                {"author": {"display_name": "Alice"}},
                {"author": {"display_name": "Bob"}},
            ],
            "publication_year": 2024,
            "doi": "https://doi.org/10.1234/test",
            "abstract": "Test abstract",
            "primary_location": {
                "source": {"display_name": "Test Journal"}
            },
            "id": "https://openalex.org/W123456",
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Test Journal"
            assert paper.source == "openalex"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = []

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles works with missing optional fields."""
        provider = OpenAlexProvider()

        # Minimal work with only required fields
        mock_work = {
            "title": "Minimal Paper",
            "authorships": [],
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None


class TestOpenAlexIntegration:
    """Integration test for the OpenAlex provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = OpenAlexProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "openalex"
        except Exception as e:
            pytest.skip(f"OpenAlex API unavailable: {e}")
@


\chapter{DBLP Provider}

DBLP is a computer science bibliography database hosted at the University of
Trier and Schloss Dagstuhl.
It provides comprehensive coverage of major computer science journals and
conference proceedings.

\section{Package evaluation}

We evaluated several Python packages for DBLP access:

\begin{description}
\item[dblpy-lib (0.1.3)] Appeared well-maintained with a clean API
  ([[get_publications(q, max_results)]]).
  However, it requires [[requests>=2.27.1,<2.28.0]], which conflicts with our
  [[requests^2.31]] dependency.
\item[dblp (0.1.0)] Returns pandas DataFrames, which seemed convenient.
  However, it fails to install due to a bug in its setup script---it passes a
  list where a string is expected ([[TypeError: expected string or bytes-like
  object, got 'list']]).
\end{description}

Given these issues, we use the DBLP public API directly via [[requests]], which
we already depend on.
No API key is required.
The API returns JSON with publication data that we parse directly.

\section{Provider implementation}

<<dblp provider>>=
class DBLPProvider:
    """Search provider for DBLP."""

    name = "dblp"

    def __init__(self):
        """Initialize the DBLP provider."""
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search DBLP for papers matching the query."""
        try:
            # DBLP API caps at 1000 results per request
            effective_limit = min(limit, 1000)
            response = requests.get(
                DBLP_API_URL,
                params={"q": query, "format": "json", "h": effective_limit},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("result", {}).get("hits", {}).get("hit", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception:
            return []

    <<convert dblp hit>>
@

\subsection{Converting publication format}

The DBLP API returns each publication as a JSON object with an [[info]] field
containing:
\begin{description}
\item[authors] Object with [[author]] array, each having a [[text]] field.
\item[title] The publication title.
\item[venue] The venue (conference or journal).
\item[year] Publication year as string.
\item[doi] The DOI (if available).
\item[ee] Electronic edition URL.
\item[url] URL to the DBLP record.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert dblp hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a DBLP API hit to our Paper type."""
    info = hit.get("info", {})

    # Extract year as integer if available
    year = None
    year_str = info.get("year")
    if year_str:
        try:
            year = int(year_str)
        except (ValueError, TypeError):
            pass

    # Extract author names from nested structure
    authors = []
    authors_data = info.get("authors", {}).get("author", [])
    # Handle single author (dict) vs multiple authors (list)
    if isinstance(authors_data, dict):
        authors_data = [authors_data]
    for author in authors_data:
        name = author.get("text") if isinstance(author, dict) else author
        if name:
            authors.append(name)

    return Paper(
        title=info.get("title", "") or "",
        authors=authors,
        year=year,
        doi=info.get("doi"),
        abstract=None,  # DBLP doesn't provide abstracts
        venue=info.get("venue"),
        url=info.get("url") or info.get("ee"),
        source=self.name,
    )
@

\section{Auto-registration}

<<dblp provider>>=
# Register the provider on module import
register_provider(DBLPProvider())
@

\section{Dependencies}

<<dblp imports>>=
import requests
@

<<dblp constants>>=
DBLP_API_URL = "https://dblp.org/search/publ/api"
@

\section{Testing DBLP provider}

We test the DBLP provider with mocked API responses:

<<test dblp>>=
class TestDBLPProvider:
    """Tests for the DBLP provider."""

    def test_search_converts_publications(self):
        """search() converts API results to Paper objects."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Test Paper",
                            "authors": {
                                "author": [
                                    {"text": "Alice"},
                                    {"text": "Bob"},
                                ]
                            },
                            "year": "2024",
                            "venue": "ICSE",
                            "doi": "10.1234/test",
                            "url": "https://dblp.org/rec/conf/icse/Test24",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "ICSE"
            assert paper.source == "dblp"

    def test_search_handles_single_author(self):
        """search() handles single author as dict instead of list."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Solo Paper",
                            "authors": {"author": {"text": "Solo Author"}},
                            "year": "2024",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            assert results[0].authors == ["Solo Author"]

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {"hits": {"hit": []}}
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = DBLPProvider()

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles publications with missing optional fields."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {"title": "Minimal Paper"}
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_respects_limit_parameter(self):
        """search() passes limit to API."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=50)

            mock_get.assert_called_once()
            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 50

    def test_caps_limit_at_1000(self):
        """search() caps limit at DBLP's maximum of 1000."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=2000)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 1000


class TestDBLPIntegration:
    """Integration test for the DBLP provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = DBLPProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "dblp"
        except Exception as e:
            pytest.skip(f"DBLP API unavailable: {e}")
@


\chapter{Web of Science Provider}

Web of Science (WoS) is a comprehensive citation index covering scholarly
literature across sciences, social sciences, arts, and humanities.
It is maintained by Clarivate and requires institutional access or an API key.

\section{API options}

Clarivate provides several API options:

\begin{description}
\item[Web of Science API Expanded] Full access with advanced features.
  Requires institutional subscription.
\item[Web of Science Starter API] Basic search with bibliographic metadata.
  Has a free tier (50 requests/day) and institutional tiers (5,000--20,000
  requests/day).
\end{description}

The official Python client ([[wosstarter_python_client]]) is only available
from GitHub, not PyPI.
For consistency with our DBLP implementation, we use the Starter API's REST
endpoint directly via [[requests]].

\section{Provider implementation}

<<wos provider>>=
class WebOfScienceProvider:
    """Search provider for Web of Science."""

    name = "wos"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Web of Science provider.

        Args:
            api_key: API key for WoS Starter API.
                     If not provided, uses WOS_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("WOS_API_KEY")
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search Web of Science for papers matching the query."""
        if not self.api_key:
            return []  # No API key configured

        try:
            # WoS Starter API has max 50 results per page
            effective_limit = min(limit, 50)
            response = requests.get(
                WOS_API_URL,
                params={
                    "q": query,
                    "db": "WOS",
                    "limit": effective_limit,
                    "page": 1,
                },
                headers={"X-ApiKey": self.api_key},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("hits", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception:
            return []

    <<convert wos hit>>
@

\subsection{Converting document format}

The WoS Starter API returns documents with fields including:
\begin{description}
\item[uid] Unique WoS identifier.
\item[title] The document title.
\item[names] Object with [[authors]] array containing author names.
\item[source] Source publication information including [[sourceTitle]].
\item[links] Object with [[record]] URL to WoS page.
\item[identifiers] Object with DOI and other identifiers.
\item[keywords] Object with [[authorKeywords]] array.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert wos hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a WoS API hit to our Paper type."""
    # Extract publication year from source
    source = hit.get("source", {})
    year = None
    pub_year = source.get("publishYear")
    if pub_year:
        try:
            year = int(pub_year)
        except (ValueError, TypeError):
            pass

    # Extract author names
    authors = []
    names = hit.get("names", {})
    for author in names.get("authors", []):
        name = author.get("displayName")
        if name:
            authors.append(name)

    # Extract DOI from identifiers
    doi = None
    identifiers = hit.get("identifiers", {})
    doi = identifiers.get("doi")

    # Extract URL from links
    url = None
    links = hit.get("links", {})
    url = links.get("record")

    return Paper(
        title=hit.get("title", "") or "",
        authors=authors,
        year=year,
        doi=doi,
        abstract=None,  # Not available in Starter API
        venue=source.get("sourceTitle"),
        url=url,
        source=self.name,
    )
@

\section{Auto-registration}

<<wos provider>>=
# Register the provider on module import
register_provider(WebOfScienceProvider())
@

\section{Dependencies}

Since the provider uses the same [[requests]] library as DBLP, we only need
to define the API URL constant:

<<wos constants>>=
WOS_API_URL = "https://api.clarivate.com/apis/wos-starter/v1/documents"
@

\section{Testing Web of Science provider}

We test the WoS provider with mocked API responses.
Note that without an API key, the provider returns empty results:

<<test wos>>=
class TestWebOfScienceProvider:
    """Tests for the Web of Science provider."""

    def test_search_returns_empty_without_api_key(self):
        """search() returns empty list when no API key is configured."""
        provider = WebOfScienceProvider(api_key=None)
        results = provider.search("test")
        assert results == []

    def test_search_converts_documents(self):
        """search() converts API results to Paper objects."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{
                "title": "Test Paper",
                "names": {
                    "authors": [
                        {"displayName": "Alice Smith"},
                        {"displayName": "Bob Jones"},
                    ]
                },
                "source": {
                    "sourceTitle": "Nature",
                    "publishYear": "2024",
                },
                "identifiers": {"doi": "10.1234/test"},
                "links": {"record": "https://wos.com/record/123"},
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice Smith", "Bob Jones"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Nature"
            assert paper.source == "wos"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = WebOfScienceProvider(api_key="test_key")

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles documents with missing optional fields."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{"title": "Minimal Paper"}]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_caps_limit_at_50(self):
        """search() caps limit at WoS Starter API's maximum of 50."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=100)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["limit"] == 50

    def test_sends_api_key_header(self):
        """search() sends API key in header."""
        provider = WebOfScienceProvider(api_key="my_secret_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test")

            call_args = mock_get.call_args
            assert call_args[1]["headers"]["X-ApiKey"] == "my_secret_key"


class TestWebOfScienceIntegration:
    """Integration test for the Web of Science provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default; requires WOS_API_KEY")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        import os

        api_key = os.environ.get("WOS_API_KEY")
        if not api_key:
            pytest.skip("WOS_API_KEY environment variable not set")

        provider = WebOfScienceProvider(api_key=api_key)

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "wos"
        except Exception as e:
            pytest.skip(f"Web of Science API unavailable: {e}")
@


\chapter{IEEE Xplore Provider}

IEEE Xplore is a research database providing access to scientific and technical
content published by IEEE (Institute of Electrical and Electronics Engineers)
and its publishing partners.
It contains over 6 million documents including journals, conference proceedings,
technical standards, and books.

\section{API access}

IEEE provides a Metadata API for searching and retrieving bibliographic data.
The API requires registration and an API key, which can be obtained from the
IEEE Developer Portal.

The official Python SDK ([[xploreapi]]) is provided by IEEE but is not available
on PyPI---it must be downloaded from the Developer Portal.
For consistency with our other providers, we use the REST API directly via
[[requests]].

\section{Provider implementation}

<<ieee provider>>=
class IEEEXploreProvider:
    """Search provider for IEEE Xplore."""

    name = "ieee"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the IEEE Xplore provider.

        Args:
            api_key: API key for IEEE Xplore API.
                     If not provided, uses IEEE_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("IEEE_API_KEY")
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search IEEE Xplore for papers matching the query."""
        if not self.api_key:
            return []  # No API key configured

        try:
            # IEEE API returns max 200 results per request
            effective_limit = min(limit, 200)
            response = requests.get(
                IEEE_API_URL,
                params={
                    "querytext": query,
                    "max_records": effective_limit,
                    "apikey": self.api_key,
                },
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            articles = data.get("articles", [])
            return [self._convert_article(article) for article in articles]
        except Exception:
            return []

    <<convert ieee article>>
@

\subsection{Converting article format}

The IEEE Xplore API returns articles with fields including:
\begin{description}
\item[title] The document title.
\item[authors] Object with [[authors]] array containing author details.
\item[abstract] Brief summary of the document.
\item[publication\_title] Journal or conference name.
\item[publication\_year] Year of publication.
\item[doi] Digital Object Identifier.
\item[html\_url] URL to the article page.
\end{description}

We convert each article to our common [[Paper]] type:

<<convert ieee article>>=
def _convert_article(self, article: dict) -> Paper:
    """Convert an IEEE Xplore article to our Paper type."""
    # Extract publication year
    year = None
    pub_year = article.get("publication_year")
    if pub_year:
        try:
            year = int(pub_year)
        except (ValueError, TypeError):
            pass

    # Extract author names from authors object
    authors = []
    authors_data = article.get("authors", {}).get("authors", [])
    for author in authors_data:
        name = author.get("full_name")
        if name:
            authors.append(name)

    # Prefer html_url, fall back to abstract_url
    url = article.get("html_url") or article.get("abstract_url")

    return Paper(
        title=article.get("title", "") or "",
        authors=authors,
        year=year,
        doi=article.get("doi"),
        abstract=article.get("abstract"),
        venue=article.get("publication_title"),
        url=url,
        source=self.name,
    )
@

\section{Auto-registration}

<<ieee provider>>=
# Register the provider on module import
register_provider(IEEEXploreProvider())
@

\section{Dependencies}

Since the provider uses the same [[requests]] library as DBLP and WoS, we only
need to define the API URL constant:

<<ieee constants>>=
IEEE_API_URL = "https://ieeexploreapi.ieee.org/api/v1/search/articles"
@

\section{Testing IEEE Xplore provider}

We test the IEEE Xplore provider with mocked API responses.
Like WoS, without an API key the provider returns empty results:

<<test ieee>>=
class TestIEEEXploreProvider:
    """Tests for the IEEE Xplore provider."""

    def test_search_returns_empty_without_api_key(self):
        """search() returns empty list when no API key is configured."""
        provider = IEEEXploreProvider(api_key=None)
        results = provider.search("test")
        assert results == []

    def test_search_converts_articles(self):
        """search() converts API results to Paper objects."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{
                "title": "Test Paper on Neural Networks",
                "authors": {
                    "authors": [
                        {"full_name": "Alice Smith", "author_order": 1},
                        {"full_name": "Bob Jones", "author_order": 2},
                    ]
                },
                "abstract": "This paper presents...",
                "publication_title": "IEEE Trans. Neural Networks",
                "publication_year": "2024",
                "doi": "10.1109/TNN.2024.1234567",
                "html_url": "https://ieeexplore.ieee.org/document/1234567",
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("neural networks")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper on Neural Networks"
            assert paper.authors == ["Alice Smith", "Bob Jones"]
            assert paper.year == 2024
            assert paper.doi == "10.1109/TNN.2024.1234567"
            assert paper.abstract == "This paper presents..."
            assert paper.venue == "IEEE Trans. Neural Networks"
            assert paper.source == "ieee"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = IEEEXploreProvider(api_key="test_key")

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles articles with missing optional fields."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{"title": "Minimal Paper"}]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_caps_limit_at_200(self):
        """search() caps limit at IEEE's maximum of 200."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=500)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["max_records"] == 200

    def test_sends_api_key_as_parameter(self):
        """search() sends API key as query parameter."""
        provider = IEEEXploreProvider(api_key="my_ieee_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test")

            call_args = mock_get.call_args
            assert call_args[1]["params"]["apikey"] == "my_ieee_key"

    def test_uses_abstract_url_as_fallback(self):
        """search() uses abstract_url when html_url is not available."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{
                "title": "Paper",
                "abstract_url": "https://ieeexplore.ieee.org/abstract/1234",
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert results[0].url == "https://ieeexplore.ieee.org/abstract/1234"


class TestIEEEXploreIntegration:
    """Integration test for the IEEE Xplore provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default; requires IEEE_API_KEY")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        import os

        api_key = os.environ.get("IEEE_API_KEY")
        if not api_key:
            pytest.skip("IEEE_API_KEY environment variable not set")

        provider = IEEEXploreProvider(api_key=api_key)

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "ieee"
        except Exception as e:
            pytest.skip(f"IEEE Xplore API unavailable: {e}")
@


\chapter{Dependencies}

We organize imports so each provider's dependencies are co-located with
its implementation.
If a provider is removed, its dependencies go with it.

<<imports>>=
import os
from typing import Protocol

from cachetools import cachedmethod

from scholar import Paper
from scholar.cache import load_cache, register_cache
<<semantic scholar imports>>
<<openalex imports>>
<<dblp imports>>
@

<<constants>>=
# Provider constants
DEFAULT_LIMIT = 100
<<dblp constants>>
<<wos constants>>
<<ieee constants>>
@


\chapter{Testing}
\label{ch:providers-testing}

Tests are distributed throughout this document, appearing immediately after
each provider's implementation.
This chapter assembles all test chunks into the test file and includes the
registry tests.

<<test [[providers.py]]>>=
"""Tests for the providers module."""
import pytest
from unittest.mock import Mock, patch

from scholar import Paper
from scholar.providers import (
    SemanticScholarProvider,
    OpenAlexProvider,
    DBLPProvider,
    WebOfScienceProvider,
    IEEEXploreProvider,
    register_provider,
    get_provider,
    get_all_providers,
    PROVIDERS,
)
@


\section{Testing the registry}

The registry should store and retrieve providers:

<<test [[providers.py]]>>=
class TestProviderRegistry:
    """Tests for the provider registry."""

    def test_semantic_scholar_registered(self):
        """Semantic Scholar provider is auto-registered."""
        provider = get_provider("semantic_scholar")
        assert provider is not None
        assert provider.name == "semantic_scholar"

    def test_openalex_registered(self):
        """OpenAlex provider is auto-registered."""
        provider = get_provider("openalex")
        assert provider is not None
        assert provider.name == "openalex"

    def test_dblp_registered(self):
        """DBLP provider is auto-registered."""
        provider = get_provider("dblp")
        assert provider is not None
        assert provider.name == "dblp"

    def test_wos_registered(self):
        """Web of Science provider is auto-registered."""
        provider = get_provider("wos")
        assert provider is not None
        assert provider.name == "wos"

    def test_ieee_registered(self):
        """IEEE Xplore provider is auto-registered."""
        provider = get_provider("ieee")
        assert provider is not None
        assert provider.name == "ieee"

    def test_get_all_providers(self):
        """get_all_providers returns registered providers."""
        providers = get_all_providers()
        assert len(providers) >= 5
        names = [p.name for p in providers]
        assert "semantic_scholar" in names
        assert "openalex" in names
        assert "dblp" in names
        assert "wos" in names
        assert "ieee" in names

    def test_get_unknown_provider(self):
        """get_provider returns None for unknown providers."""
        assert get_provider("unknown_provider") is None
@


\section{Provider tests}

Tests for each provider are distributed throughout this document, appearing
immediately after each provider's implementation.
We reference them here to assemble the complete test file:

<<test [[providers.py]]>>=
<<test semantic scholar>>
<<test openalex>>
<<test dblp>>
<<test wos>>
<<test ieee>>
@
