\chapter{Search Providers}
\label{providers-module}

\section{Introduction}

This module implements search providers---adapters that connect Scholar to
various bibliographic databases.
Each provider knows how to query a specific database and convert results to
our common [[Paper]] type.

The provider abstraction allows us to:
\begin{description}
\item[Add new databases] without modifying the core search logic.
\item[Test in isolation] by mocking individual providers.
\item[Configure per-provider] settings like API keys and rate limits.
\item[Cache results] to avoid redundant API calls and respect rate limits.
\end{description}

\section{Caching}

Each provider caches search results using [[cachetools]].
The cache is a plain dictionary keyed by the query and limit parameters.
Caches are persisted to disk using pickle, so results survive across program
runs.
This is particularly useful for systematic reviews where the same search may
be run multiple times.


\section{Module structure}

The providers module exports the provider protocol and registry functions:

<<[[providers.py]]>>=
"""
Search providers for bibliographic databases.

Each provider implements the SearchProvider protocol and registers
itself with the provider registry on import.
"""

<<imports>>
<<constants>>
<<provider protocol>>
<<provider registry>>
<<semantic scholar provider>>
<<openalex provider>>
<<dblp provider>>
<<wos provider>>
<<ieee provider>>
@


\section{Testing}
\label{sec:providers-testing}

Tests are distributed throughout this document, appearing immediately after
each provider's implementation.
The test file collects all distributed test chunks:

<<test [[providers.py]]>>=
"""Tests for the providers module."""
import pytest
from unittest.mock import Mock, patch

from scholar import *
from scholar.providers import *


<<test functions>>
@


\section{Provider Protocol}
\label{sec:provider-protocol}

We define a protocol (structural typing) rather than an abstract base class.
This design choice reflects Python's \enquote{duck typing} philosophy: if an
object has a [[name]] attribute and a [[search]] method with the right
signature, it \emph{is} a provider---no inheritance required.

\subsection{Why Protocol Over ABC?}

Using [[Protocol]] from [[typing]] has several advantages over
[[abc.ABC]]:
\begin{description}
\item[No inheritance required] Providers don't need to inherit from a base
  class. This simplifies testing (mock objects work without setup) and allows
  third-party classes to be providers without modification.
\item[Explicit contracts] The protocol documents exactly what's required.
  Unlike duck typing alone, static type checkers can verify implementations.
\item[Flexibility] A class from another library could satisfy this protocol
  without knowing about Scholar, enabling future extensibility.
\end{description}

\subsection{Required Interface}

A provider must have:
\begin{description}
\item[name] A unique identifier string.
\item[search] A method that takes a query and returns papers.
\end{description}

<<provider protocol>>=
class SearchProvider(Protocol):
    """Protocol for search providers."""

    name: str

    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """
        Search for papers matching the query.

        Args:
            query: The search query string.
            limit: Maximum number of results to return.

        Returns:
            List of Paper objects matching the query.
        """
        ...
@


\section{Provider Registry}
\label{sec:provider-registry}

Providers register themselves when imported. This \emph{self-registration}
pattern allows the [[Search]] class to discover available providers without
hardcoding them.

\subsection{Why Self-Registration?}

The registry pattern provides plugin-like architecture:
\begin{description}
\item[Decoupling] The core search logic doesn't need to know about specific
  providers. Adding a new database is as simple as creating a new provider
  class and calling [[register_provider]].
\item[Lazy loading] Providers register at module import time. If a provider's
  dependencies aren't installed (e.g., missing API key), it simply won't
  register, and searches proceed with available providers.
\item[Discoverability] CLI commands can query the registry to show users
  which providers are available and configured.
\end{description}

\subsection{Implementation}

<<provider registry>>=
PROVIDERS: dict[str, SearchProvider] = {}


def register_provider(provider: SearchProvider) -> None:
    """Register a provider for use in searches."""
    PROVIDERS[provider.name] = provider


def get_provider(name: str) -> SearchProvider | None:
    """Get a provider by name, or None if not found."""
    return PROVIDERS.get(name)


def get_all_providers() -> list[SearchProvider]:
    """Get all registered providers."""
    return list(PROVIDERS.values())
@

\subsection{Testing the registry}

The registry should store and retrieve providers:

<<test functions>>=
class TestProviderRegistry:
    """Tests for the provider registry."""

    def test_semantic_scholar_registered(self):
        """Semantic Scholar provider is auto-registered."""
        provider = get_provider("semantic_scholar")
        assert provider is not None
        assert provider.name == "semantic_scholar"

    def test_openalex_registered(self):
        """OpenAlex provider is auto-registered."""
        provider = get_provider("openalex")
        assert provider is not None
        assert provider.name == "openalex"

    def test_dblp_registered(self):
        """DBLP provider is auto-registered."""
        provider = get_provider("dblp")
        assert provider is not None
        assert provider.name == "dblp"

    def test_wos_registered(self):
        """Web of Science provider is auto-registered."""
        provider = get_provider("wos")
        assert provider is not None
        assert provider.name == "wos"

    def test_ieee_registered(self):
        """IEEE Xplore provider is auto-registered."""
        provider = get_provider("ieee")
        assert provider is not None
        assert provider.name == "ieee"

    def test_get_all_providers(self):
        """get_all_providers returns registered providers."""
        providers = get_all_providers()
        assert len(providers) >= 5
        names = [p.name for p in providers]
        assert "semantic_scholar" in names
        assert "openalex" in names
        assert "dblp" in names
        assert "wos" in names
        assert "ieee" in names

    def test_get_unknown_provider(self):
        """get_provider returns None for unknown providers."""
        assert get_provider("unknown_provider") is None
@


\subsection{Default providers}
\label{sec:default-providers}

Not all registered providers are suitable as defaults.
Some require API keys that users may not have; others may have reliability
issues.
We define a separate list of \emph{default} providers---those used when no
explicit [[--provider]] argument is given.

The rationale for the current defaults:
\begin{description}
\item[openalex] Free, no API key required, fast and reliable responses.
  Covers 250+ million works with open access.
\item[dblp] Free, no API key required, reliable.
  Comprehensive coverage of computer science literature.
\end{description}

Providers \emph{not} included as defaults:
\begin{description}
\item[semantic\_scholar] Currently experiencing reliability issues
  (timeouts, no results).
  Can be explicitly requested with [[-p semantic\_scholar]].
\item[wos, ieee] Require API keys.
  Users who have keys can explicitly request them.
\end{description}

<<provider registry>>=
# Default providers used when no --provider argument is given.
# These are providers that work without API keys and have reliable performance.
DEFAULT_PROVIDERS: list[str] = ["openalex", "dblp"]


def get_default_providers() -> list[SearchProvider]:
    """Get the default providers used when no providers are specified."""
    return [PROVIDERS[name] for name in DEFAULT_PROVIDERS if name in PROVIDERS]
@

\subsubsection{Testing default providers}

The default providers should be a subset of registered providers:

<<test functions>>=
class TestDefaultProviders:
    """Tests for default provider functionality."""

    def test_default_providers_list_exists(self):
        """DEFAULT_PROVIDERS list is defined."""
        assert isinstance(DEFAULT_PROVIDERS, list)
        assert len(DEFAULT_PROVIDERS) >= 1

    def test_default_providers_are_registered(self):
        """All default providers are registered."""
        for name in DEFAULT_PROVIDERS:
            assert get_provider(name) is not None

    def test_get_default_providers(self):
        """get_default_providers returns correct providers."""
        defaults = get_default_providers()
        assert len(defaults) == len(DEFAULT_PROVIDERS)
        for provider in defaults:
            assert provider.name in DEFAULT_PROVIDERS

    def test_openalex_is_default(self):
        """OpenAlex is a default provider."""
        assert "openalex" in DEFAULT_PROVIDERS

    def test_dblp_is_default(self):
        """DBLP is a default provider."""
        assert "dblp" in DEFAULT_PROVIDERS

    def test_semantic_scholar_not_default(self):
        """Semantic Scholar is not a default (due to reliability issues)."""
        assert "semantic_scholar" not in DEFAULT_PROVIDERS

    def test_wos_not_default(self):
        """Web of Science is not a default (requires API key)."""
        assert "wos" not in DEFAULT_PROVIDERS

    def test_ieee_not_default(self):
        """IEEE Xplore is not a default (requires API key)."""
        assert "ieee" not in DEFAULT_PROVIDERS
@


\section{Semantic Scholar Provider}
\label{sec:semantic-scholar}

Semantic Scholar is an AI-powered research tool that provides free access to
over 200 million academic papers.
Their API allows searching papers by keyword, author, venue, and more.

\subsection{API Access}

We call the Semantic Scholar REST API directly using [[requests]], rather than
using the [[semanticscholar]] package.
This gives us full control over rate limiting and error handling.

The API endpoint is [[https://api.semanticscholar.org/graph/v1/paper/search]].
An optional API key ([[S2_API_KEY]]) increases rate limits:
\begin{description}
\item[Without key] 100 requests per 5 minutes (we space requests 3 seconds apart)
\item[With key] 1 request per second sustained rate
\end{description}

We implement:
\begin{itemize}
\item Adaptive rate limiting based on API key presence
\item Exponential back-off retry on server errors (429, 5xx)
\item Clear error messages explaining rate limits
\end{itemize}

\subsection{Error Handling Philosophy}

All providers return an empty list on errors rather than raising exceptions,
but they log warnings to help diagnose issues.
This design choice ensures:
\begin{description}
\item[Partial results] If one provider fails (network issue, rate limit),
  other providers can still contribute results.
\item[Robustness] Transient errors don't crash the entire search.
\item[Visibility] Errors are logged via [[logging.warning()]], so users can
  see what went wrong (e.g., rate limits, timeouts, API errors).
\item[Simplicity] Callers don't need complex exception handling.
\end{description}

To see error messages, ensure logging is configured at WARNING level or above.
The CLI's [[providers]] command helps diagnose configuration issues like
missing API keys.

\subsection{Provider implementation}

<<semantic scholar provider>>=
class SemanticScholarProvider:
    """Search provider for Semantic Scholar."""

    name = "semantic_scholar"
    API_URL = "https://api.semanticscholar.org/graph/v1/paper/search"
    RATE_LIMIT_WITH_KEY = 1.0      # 1 second between requests
    RATE_LIMIT_WITHOUT_KEY = 3.0   # 3 seconds (100 req/5min = 0.33/sec)

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Semantic Scholar provider.

        Args:
            api_key: Optional API key for higher rate limits.
                     If not provided, uses S2_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("S2_API_KEY")
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)
        self._last_request_time: float = 0.0
        self._session = self._create_session()

    <<semantic scholar rate limiting>>
    <<semantic scholar search method>>
    <<convert semantic scholar paper>>
@

\subsubsection{Rate limiting and retry}

We implement two layers of rate limiting:
\begin{enumerate}
\item \textbf{Proactive rate limiting}: We track the time of the last request
  and wait if necessary before making a new one.
  The interval depends on whether we have an API key.
\item \textbf{Exponential back-off}: If we still hit rate limits (HTTP 429) or
  server errors (5xx), we retry with increasing delays.
\end{enumerate}

<<semantic scholar rate limiting>>=
@property
def _min_request_interval(self) -> float:
    """Return minimum interval based on whether API key is set."""
    if self.api_key:
        return self.RATE_LIMIT_WITH_KEY
    return self.RATE_LIMIT_WITHOUT_KEY

def _create_session(self) -> requests.Session:
    """Create a session with exponential back-off retry logic."""
    session = requests.Session()
    retry = Retry(
        total=3,
        backoff_factor=1,  # 1s, 2s, 4s delays
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET"],
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount("https://", adapter)
    return session

def _wait_for_rate_limit(self) -> None:
    """Ensure minimum interval between requests."""
    elapsed = time.time() - self._last_request_time
    if elapsed < self._min_request_interval:
        time.sleep(self._min_request_interval - elapsed)
    self._last_request_time = time.time()
@

\subsubsection{Search method}

The search method calls the API with rate limiting and handles errors:

<<semantic scholar search method>>=
@cachedmethod(lambda self: self._cache)
def search(self, query: str, limit: int = 100) -> list[Paper]:
    """Search Semantic Scholar for papers matching the query."""
    try:
        self._wait_for_rate_limit()

        headers = {}
        if self.api_key:
            headers["x-api-key"] = self.api_key

        response = self._session.get(
            self.API_URL,
            params={
                "query": query,
                "limit": limit,
                "fields": "title,authors,year,abstract,venue,externalIds,url,openAccessPdf",
            },
            headers=headers,
            timeout=30,
        )

        if response.status_code == 429:
            logger.warning(
                "semantic_scholar: Rate limited. "
                "Get a free API key at "
                "https://www.semanticscholar.org/product/api#api-key-form "
                "and set S2_API_KEY environment variable."
            )
            return []

        response.raise_for_status()
        data = response.json()

        return [self._convert_paper(p) for p in data.get("data", [])]
    except requests.exceptions.RetryError:
        logger.warning(
            "semantic_scholar: Rate limited after retries. "
            "Get a free API key at "
            "https://www.semanticscholar.org/product/api#api-key-form "
            "and set S2_API_KEY environment variable."
        )
        return []
    except requests.exceptions.HTTPError as e:
        logger.warning("semantic_scholar: HTTP error: %s", e)
        return []
    except Exception as e:
        logger.warning("semantic_scholar: %s", e)
        return []
@

\subsubsection{Converting paper format}

Semantic Scholar returns papers as JSON dictionaries.
We convert them to our common [[Paper]] type:

<<convert semantic scholar paper>>=
def _convert_paper(self, paper_data: dict) -> Paper:
    """Convert a Semantic Scholar API response to our Paper type."""
    # Extract DOI from externalIds if available
    doi = None
    external_ids = paper_data.get("externalIds") or {}
    if external_ids:
        doi = external_ids.get("DOI")

    # Extract author names from list of author dicts
    authors = []
    for author in paper_data.get("authors") or []:
        if author.get("name"):
            authors.append(author["name"])

    # Extract PDF URL from openAccessPdf if available
    pdf_url = None
    open_access_pdf = paper_data.get("openAccessPdf") or {}
    if open_access_pdf:
        pdf_url = open_access_pdf.get("url")

    return Paper(
        title=paper_data.get("title") or "",
        authors=authors,
        year=paper_data.get("year"),
        doi=doi,
        abstract=paper_data.get("abstract"),
        venue=paper_data.get("venue"),
        url=paper_data.get("url"),
        pdf_url=pdf_url,
        source=self.name,
    )
@

\subsection{Auto-registration}

We register the provider when this module is imported:

<<semantic scholar provider>>=
# Register the provider on module import
register_provider(SemanticScholarProvider())
@

\subsection{Dependencies}

<<semantic scholar imports>>=
import time

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
@

\subsection{Testing Semantic Scholar provider}

We mock the HTTP requests to avoid real network calls in tests:

<<test functions>>=
class TestSemanticScholarProvider:
    """Tests for the SemanticScholar provider."""

    def test_search_converts_papers(self):
        """search() converts API results to Paper objects."""
        provider = SemanticScholarProvider()

        # Mock API response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "total": 1,
            "data": [{
                "paperId": "abc123",
                "title": "Test Paper",
                "authors": [{"name": "Alice"}, {"name": "Bob"}],
                "year": 2024,
                "externalIds": {"DOI": "10.1234/test"},
                "abstract": "Test abstract",
                "venue": "Test Conference",
                "url": "https://example.com/paper",
                "openAccessPdf": {
                    "url": "https://arxiv.org/pdf/1234.5678.pdf",
                    "status": "GREEN",
                },
            }]
        }

        with patch.object(provider._session, "get", return_value=mock_response):
            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.source == "semantic_scholar"
            assert "Alice" in paper.authors
            assert "Bob" in paper.authors
            assert paper.pdf_url == "https://arxiv.org/pdf/1234.5678.pdf"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = SemanticScholarProvider()

        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"total": 0, "data": []}

        with patch.object(provider._session, "get", return_value=mock_response):
            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = SemanticScholarProvider()

        with patch.object(provider._session, "get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_search_handles_rate_limit(self):
        """search() returns empty list on rate limit (429)."""
        provider = SemanticScholarProvider()

        mock_response = Mock()
        mock_response.status_code = 429

        with patch.object(provider._session, "get", return_value=mock_response):
            results = provider.search("test")
            assert results == []

    def test_rate_limiting_with_api_key(self):
        """Provider uses faster rate limit when API key is set."""
        provider = SemanticScholarProvider(api_key="test-key")
        assert provider._min_request_interval == 1.0

    def test_rate_limiting_without_api_key(self):
        """Provider uses slower rate limit without API key."""
        with patch.dict(os.environ, {}, clear=True):
            # Ensure no S2_API_KEY in environment
            if "S2_API_KEY" in os.environ:
                del os.environ["S2_API_KEY"]
            provider = SemanticScholarProvider(api_key=None)
            # Force api_key to None even if env var exists
            provider.api_key = None
            assert provider._min_request_interval == 3.0


class TestSemanticScholarIntegration:
    """Integration test for the SemanticScholar provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default due to API rate limits")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        try:
            provider = SemanticScholarProvider()
            papers = provider.search("machine learning", limit=1)
            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "semantic_scholar"
        except Exception as e:
            pytest.skip(f"Semantic Scholar API unavailable: {e}")
@


\section{OpenAlex Provider}
\label{sec:openalex}

OpenAlex is a free and open catalog of the world's scholarly works, authors,
venues, institutions, and concepts.
It covers over 250 million works and is fully open access.

\subsection{Package Choice}

We use the [[pyalex]] Python package which provides a clean interface to the
OpenAlex API. Unlike Semantic Scholar's package, [[pyalex]] returns raw
dictionaries rather than typed objects, requiring manual field extraction.

\subsection{Authentication}

No API key is required, but providing an email address (via [[OPENALEX_EMAIL]]
environment variable) gives access to the \enquote{polite pool}---a separate
pool of API resources with faster response times for identified users.

This is OpenAlex's approach to encouraging good API citizenship without
creating barriers to access.

\subsection{Provider implementation}

<<openalex provider>>=
class OpenAlexProvider:
    """Search provider for OpenAlex."""

    name = "openalex"

    def __init__(self, email: str | None = None):
        """
        Initialize the OpenAlex provider.

        Args:
            email: Optional email for polite pool access (faster responses).
                   If not provided, uses OPENALEX_EMAIL environment variable.
        """
        configured_email = email or os.environ.get("OPENALEX_EMAIL")
        if configured_email:
            pyalex.config.email = configured_email
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search OpenAlex for papers matching the query."""
        try:
            works = pyalex.Works().search(query).get(per_page=limit)
            return [self._convert_work(w) for w in works]
        except Exception as e:
            logger.warning("openalex: %s", e)
            return []

    <<convert openalex work>>
@

\subsubsection{Converting work format}

OpenAlex returns works as dictionaries.
We extract the relevant fields and convert to our [[Paper]] type:

<<convert openalex work>>=
def _convert_work(self, work: dict) -> Paper:
    """Convert an OpenAlex work to our Paper type."""
    # Extract author names from authorships
    authors = []
    for authorship in work.get("authorships", []):
        author_info = authorship.get("author", {})
        name = author_info.get("display_name")
        if name:
            authors.append(name)

    # Extract DOI (remove URL prefix if present)
    doi = work.get("doi")
    if doi and doi.startswith("https://doi.org/"):
        doi = doi[16:]

    # Extract venue from primary location
    venue = None
    primary_location = work.get("primary_location", {})
    if primary_location:
        source = primary_location.get("source", {})
        if source:
            venue = source.get("display_name")

    # Extract PDF URL from open_access or primary_location
    pdf_url = None
    open_access = work.get("open_access", {})
    if open_access:
        pdf_url = open_access.get("oa_url")
    if not pdf_url and primary_location:
        pdf_url = primary_location.get("pdf_url")

    return Paper(
        title=work.get("title", ""),
        authors=authors,
        year=work.get("publication_year"),
        doi=doi,
        abstract=work.get("abstract"),
        venue=venue,
        url=work.get("id"),
        pdf_url=pdf_url,
        source=self.name,
    )
@

\subsection{Auto-registration}

<<openalex provider>>=
# Register the provider on module import
register_provider(OpenAlexProvider())
@

\subsection{Dependencies}

<<openalex imports>>=
import pyalex
@

\subsection{Testing OpenAlex provider}

We test the OpenAlex provider with mocked API responses:

<<test functions>>=
class TestOpenAlexProvider:
    """Tests for the OpenAlex provider."""

    def test_search_converts_works(self):
        """search() converts API results to Paper objects."""
        provider = OpenAlexProvider()

        # Create mock work (OpenAlex returns dicts)
        mock_work = {
            "title": "Test Paper",
            "authorships": [
                {"author": {"display_name": "Alice"}},
                {"author": {"display_name": "Bob"}},
            ],
            "publication_year": 2024,
            "doi": "https://doi.org/10.1234/test",
            "abstract": "Test abstract",
            "primary_location": {
                "source": {"display_name": "Test Journal"}
            },
            "id": "https://openalex.org/W123456",
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Test Journal"
            assert paper.source == "openalex"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = []

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = OpenAlexProvider()

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles works with missing optional fields."""
        provider = OpenAlexProvider()

        # Minimal work with only required fields
        mock_work = {
            "title": "Minimal Paper",
            "authorships": [],
        }

        with patch("pyalex.Works") as mock_works:
            mock_works.return_value.search.return_value.get.return_value = [
                mock_work
            ]

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None


class TestOpenAlexIntegration:
    """Integration test for the OpenAlex provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = OpenAlexProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "openalex"
        except Exception as e:
            pytest.skip(f"OpenAlex API unavailable: {e}")
@


\section{DBLP Provider}

DBLP is a computer science bibliography database hosted at the University of
Trier and Schloss Dagstuhl.
It provides comprehensive coverage of major computer science journals and
conference proceedings.

\subsection{Package evaluation}

We evaluated several Python packages for DBLP access:

\begin{description}
\item[dblpy-lib (0.1.3)] Appeared well-maintained with a clean API
  ([[get_publications(q, max_results)]]).
  However, it requires [[requests>=2.27.1,<2.28.0]], which conflicts with our
  [[requests^2.31]] dependency.
\item[dblp (0.1.0)] Returns pandas DataFrames, which seemed convenient.
  However, it fails to install due to a bug in its setup script---it passes a
  list where a string is expected ([[TypeError: expected string or bytes-like
  object, got 'list']]).
\end{description}

Given these issues, we use the DBLP public API directly via [[requests]], which
we already depend on.
No API key is required.
The API returns JSON with publication data that we parse directly.

\subsection{Provider implementation}

<<dblp provider>>=
class DBLPProvider:
    """Search provider for DBLP."""

    name = "dblp"

    def __init__(self):
        """Initialize the DBLP provider."""
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search DBLP for papers matching the query."""
        try:
            # DBLP API caps at 1000 results per request
            effective_limit = min(limit, 1000)
            response = requests.get(
                DBLP_API_URL,
                params={"q": query, "format": "json", "h": effective_limit},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("result", {}).get("hits", {}).get("hit", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception as e:
            logger.warning("dblp: %s", e)
            return []

    <<convert dblp hit>>
@

\subsubsection{Converting publication format}

The DBLP API returns each publication as a JSON object with an [[info]] field
containing:
\begin{description}
\item[authors] Object with [[author]] array, each having a [[text]] field.
\item[title] The publication title.
\item[venue] The venue (conference or journal).
\item[year] Publication year as string.
\item[doi] The DOI (if available).
\item[ee] Electronic edition URL.
\item[url] URL to the DBLP record.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert dblp hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a DBLP API hit to our Paper type."""
    info = hit.get("info", {})

    # Extract year as integer if available
    year = None
    year_str = info.get("year")
    if year_str:
        try:
            year = int(year_str)
        except (ValueError, TypeError):
            pass

    # Extract author names from nested structure
    authors = []
    authors_data = info.get("authors", {}).get("author", [])
    # Handle single author (dict) vs multiple authors (list)
    if isinstance(authors_data, dict):
        authors_data = [authors_data]
    for author in authors_data:
        name = author.get("text") if isinstance(author, dict) else author
        if name:
            authors.append(name)

    return Paper(
        title=info.get("title", "") or "",
        authors=authors,
        year=year,
        doi=info.get("doi"),
        abstract=None,  # DBLP doesn't provide abstracts
        venue=info.get("venue"),
        url=info.get("url") or info.get("ee"),
        source=self.name,
    )
@

\subsection{Auto-registration}

<<dblp provider>>=
# Register the provider on module import
register_provider(DBLPProvider())
@

\subsection{Dependencies}

<<dblp imports>>=
import requests
@

<<dblp constants>>=
DBLP_API_URL = "https://dblp.org/search/publ/api"
@

\subsection{Testing DBLP provider}

We test the DBLP provider with mocked API responses:

<<test functions>>=
class TestDBLPProvider:
    """Tests for the DBLP provider."""

    def test_search_converts_publications(self):
        """search() converts API results to Paper objects."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Test Paper",
                            "authors": {
                                "author": [
                                    {"text": "Alice"},
                                    {"text": "Bob"},
                                ]
                            },
                            "year": "2024",
                            "venue": "ICSE",
                            "doi": "10.1234/test",
                            "url": "https://dblp.org/rec/conf/icse/Test24",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice", "Bob"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "ICSE"
            assert paper.source == "dblp"

    def test_search_handles_single_author(self):
        """search() handles single author as dict instead of list."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {
                            "title": "Solo Paper",
                            "authors": {"author": {"text": "Solo Author"}},
                            "year": "2024",
                        }
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            assert results[0].authors == ["Solo Author"]

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {"hits": {"hit": []}}
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = DBLPProvider()

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles publications with missing optional fields."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {
            "result": {
                "hits": {
                    "hit": [{
                        "info": {"title": "Minimal Paper"}
                    }]
                }
            }
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_respects_limit_parameter(self):
        """search() passes limit to API."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=50)

            mock_get.assert_called_once()
            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 50

    def test_caps_limit_at_1000(self):
        """search() caps limit at DBLP's maximum of 1000."""
        provider = DBLPProvider()

        mock_response = Mock()
        mock_response.json.return_value = {"result": {"hits": {"hit": []}}}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=2000)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["h"] == 1000


class TestDBLPIntegration:
    """Integration test for the DBLP provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default to avoid API calls")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        provider = DBLPProvider()

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "dblp"
        except Exception as e:
            pytest.skip(f"DBLP API unavailable: {e}")
@


\section{Web of Science Provider}

Web of Science (WoS) is a comprehensive citation index covering scholarly
literature across sciences, social sciences, arts, and humanities.
It is maintained by Clarivate and requires institutional access or an API key.

\subsection{API options}

Clarivate provides several API options:

\begin{description}
\item[Web of Science API Expanded] Full access with advanced features.
  Requires institutional subscription.
\item[Web of Science Starter API] Basic search with bibliographic metadata.
  Has a free tier (50 requests/day) and institutional tiers (5,000--20,000
  requests/day).
\end{description}

The official Python client ([[wosstarter_python_client]]) is only available
from GitHub, not PyPI.
For consistency with our DBLP implementation, we use the Starter API's REST
endpoint directly via [[requests]].

\subsection{Provider implementation}

<<wos provider>>=
class WebOfScienceProvider:
    """Search provider for Web of Science."""

    name = "wos"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the Web of Science provider.

        Args:
            api_key: API key for WoS Starter API.
                     If not provided, uses WOS_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("WOS_API_KEY")
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search Web of Science for papers matching the query."""
        if not self.api_key:
            return []  # No API key configured

        try:
            # WoS Starter API has max 50 results per page
            effective_limit = min(limit, 50)
            response = requests.get(
                WOS_API_URL,
                params={
                    "q": query,
                    "db": "WOS",
                    "limit": effective_limit,
                    "page": 1,
                },
                headers={"X-ApiKey": self.api_key},
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            hits = data.get("hits", [])
            return [self._convert_hit(hit) for hit in hits]
        except Exception as e:
            logger.warning("wos: %s", e)
            return []

    <<convert wos hit>>
@

\subsubsection{Converting document format}

The WoS Starter API returns documents with fields including:
\begin{description}
\item[uid] Unique WoS identifier.
\item[title] The document title.
\item[names] Object with [[authors]] array containing author names.
\item[source] Source publication information including [[sourceTitle]].
\item[links] Object with [[record]] URL to WoS page.
\item[identifiers] Object with DOI and other identifiers.
\item[keywords] Object with [[authorKeywords]] array.
\end{description}

We convert each hit to our common [[Paper]] type:

<<convert wos hit>>=
def _convert_hit(self, hit: dict) -> Paper:
    """Convert a WoS API hit to our Paper type."""
    # Extract publication year from source
    source = hit.get("source", {})
    year = None
    pub_year = source.get("publishYear")
    if pub_year:
        try:
            year = int(pub_year)
        except (ValueError, TypeError):
            pass

    # Extract author names
    authors = []
    names = hit.get("names", {})
    for author in names.get("authors", []):
        name = author.get("displayName")
        if name:
            authors.append(name)

    # Extract DOI from identifiers
    doi = None
    identifiers = hit.get("identifiers", {})
    doi = identifiers.get("doi")

    # Extract URL from links
    url = None
    links = hit.get("links", {})
    url = links.get("record")

    return Paper(
        title=hit.get("title", "") or "",
        authors=authors,
        year=year,
        doi=doi,
        abstract=None,  # Not available in Starter API
        venue=source.get("sourceTitle"),
        url=url,
        source=self.name,
    )
@

\subsection{Auto-registration}

<<wos provider>>=
# Register the provider on module import
register_provider(WebOfScienceProvider())
@

\subsection{Dependencies}

Since the provider uses the same [[requests]] library as DBLP, we only need
to define the API URL constant:

<<wos constants>>=
WOS_API_URL = "https://api.clarivate.com/apis/wos-starter/v1/documents"
@

\subsection{Testing Web of Science provider}

We test the WoS provider with mocked API responses.
Note that without an API key, the provider returns empty results:

<<test functions>>=
class TestWebOfScienceProvider:
    """Tests for the Web of Science provider."""

    def test_search_returns_empty_without_api_key(self):
        """search() returns empty list when no API key is configured."""
        provider = WebOfScienceProvider(api_key=None)
        results = provider.search("test")
        assert results == []

    def test_search_converts_documents(self):
        """search() converts API results to Paper objects."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{
                "title": "Test Paper",
                "names": {
                    "authors": [
                        {"displayName": "Alice Smith"},
                        {"displayName": "Bob Jones"},
                    ]
                },
                "source": {
                    "sourceTitle": "Nature",
                    "publishYear": "2024",
                },
                "identifiers": {"doi": "10.1234/test"},
                "links": {"record": "https://wos.com/record/123"},
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test query")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper"
            assert paper.authors == ["Alice Smith", "Bob Jones"]
            assert paper.year == 2024
            assert paper.doi == "10.1234/test"
            assert paper.venue == "Nature"
            assert paper.source == "wos"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = WebOfScienceProvider(api_key="test_key")

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles documents with missing optional fields."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "hits": [{"title": "Minimal Paper"}]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_caps_limit_at_50(self):
        """search() caps limit at WoS Starter API's maximum of 50."""
        provider = WebOfScienceProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=100)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["limit"] == 50

    def test_sends_api_key_header(self):
        """search() sends API key in header."""
        provider = WebOfScienceProvider(api_key="my_secret_key")

        mock_response = Mock()
        mock_response.json.return_value = {"hits": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test")

            call_args = mock_get.call_args
            assert call_args[1]["headers"]["X-ApiKey"] == "my_secret_key"


class TestWebOfScienceIntegration:
    """Integration test for the Web of Science provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default; requires WOS_API_KEY")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        import os

        api_key = os.environ.get("WOS_API_KEY")
        if not api_key:
            pytest.skip("WOS_API_KEY environment variable not set")

        provider = WebOfScienceProvider(api_key=api_key)

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "wos"
        except Exception as e:
            pytest.skip(f"Web of Science API unavailable: {e}")
@


\section{IEEE Xplore Provider}

IEEE Xplore is a research database providing access to scientific and technical
content published by IEEE (Institute of Electrical and Electronics Engineers)
and its publishing partners.
It contains over 6 million documents including journals, conference proceedings,
technical standards, and books.

\subsection{API access}

IEEE provides a Metadata API for searching and retrieving bibliographic data.
The API requires registration and an API key, which can be obtained from the
IEEE Developer Portal.

The official Python SDK ([[xploreapi]]) is provided by IEEE but is not available
on PyPI---it must be downloaded from the Developer Portal.
For consistency with our other providers, we use the REST API directly via
[[requests]].

\subsection{Provider implementation}

<<ieee provider>>=
class IEEEXploreProvider:
    """Search provider for IEEE Xplore."""

    name = "ieee"

    def __init__(self, api_key: str | None = None):
        """
        Initialize the IEEE Xplore provider.

        Args:
            api_key: API key for IEEE Xplore API.
                     If not provided, uses IEEE_API_KEY environment variable.
        """
        self.api_key = api_key or os.environ.get("IEEE_API_KEY")
        self._cache: dict = load_cache(self.name)
        register_cache(self.name, self._cache)

    @cachedmethod(lambda self: self._cache)
    def search(self, query: str, limit: int = 100) -> list[Paper]:
        """Search IEEE Xplore for papers matching the query."""
        if not self.api_key:
            return []  # No API key configured

        try:
            # IEEE API returns max 200 results per request
            effective_limit = min(limit, 200)
            response = requests.get(
                IEEE_API_URL,
                params={
                    "querytext": query,
                    "max_records": effective_limit,
                    "apikey": self.api_key,
                },
                timeout=30,
            )
            response.raise_for_status()
            data = response.json()

            articles = data.get("articles", [])
            return [self._convert_article(article) for article in articles]
        except Exception as e:
            logger.warning("ieee: %s", e)
            return []

    <<convert ieee article>>
@

\subsubsection{Converting article format}

The IEEE Xplore API returns articles with fields including:
\begin{description}
\item[title] The document title.
\item[authors] Object with [[authors]] array containing author details.
\item[abstract] Brief summary of the document.
\item[publication\_title] Journal or conference name.
\item[publication\_year] Year of publication.
\item[doi] Digital Object Identifier.
\item[html\_url] URL to the article page.
\end{description}

We convert each article to our common [[Paper]] type:

<<convert ieee article>>=
def _convert_article(self, article: dict) -> Paper:
    """Convert an IEEE Xplore article to our Paper type."""
    # Extract publication year
    year = None
    pub_year = article.get("publication_year")
    if pub_year:
        try:
            year = int(pub_year)
        except (ValueError, TypeError):
            pass

    # Extract author names from authors object
    authors = []
    authors_data = article.get("authors", {}).get("authors", [])
    for author in authors_data:
        name = author.get("full_name")
        if name:
            authors.append(name)

    # Prefer html_url, fall back to abstract_url
    url = article.get("html_url") or article.get("abstract_url")

    return Paper(
        title=article.get("title", "") or "",
        authors=authors,
        year=year,
        doi=article.get("doi"),
        abstract=article.get("abstract"),
        venue=article.get("publication_title"),
        url=url,
        source=self.name,
    )
@

\subsection{Auto-registration}

<<ieee provider>>=
# Register the provider on module import
register_provider(IEEEXploreProvider())
@

\subsection{Dependencies}

Since the provider uses the same [[requests]] library as DBLP and WoS, we only
need to define the API URL constant:

<<ieee constants>>=
IEEE_API_URL = "https://ieeexploreapi.ieee.org/api/v1/search/articles"
@

\subsection{Testing IEEE Xplore provider}

We test the IEEE Xplore provider with mocked API responses.
Like WoS, without an API key the provider returns empty results:

<<test functions>>=
class TestIEEEXploreProvider:
    """Tests for the IEEE Xplore provider."""

    def test_search_returns_empty_without_api_key(self):
        """search() returns empty list when no API key is configured."""
        provider = IEEEXploreProvider(api_key=None)
        results = provider.search("test")
        assert results == []

    def test_search_converts_articles(self):
        """search() converts API results to Paper objects."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{
                "title": "Test Paper on Neural Networks",
                "authors": {
                    "authors": [
                        {"full_name": "Alice Smith", "author_order": 1},
                        {"full_name": "Bob Jones", "author_order": 2},
                    ]
                },
                "abstract": "This paper presents...",
                "publication_title": "IEEE Trans. Neural Networks",
                "publication_year": "2024",
                "doi": "10.1109/TNN.2024.1234567",
                "html_url": "https://ieeexplore.ieee.org/document/1234567",
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("neural networks")

            assert len(results) == 1
            paper = results[0]
            assert isinstance(paper, Paper)
            assert paper.title == "Test Paper on Neural Networks"
            assert paper.authors == ["Alice Smith", "Bob Jones"]
            assert paper.year == 2024
            assert paper.doi == "10.1109/TNN.2024.1234567"
            assert paper.abstract == "This paper presents..."
            assert paper.venue == "IEEE Trans. Neural Networks"
            assert paper.source == "ieee"

    def test_search_handles_empty_results(self):
        """search() returns empty list when no results."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("obscure query")
            assert results == []

    def test_search_handles_api_error(self):
        """search() returns empty list on API error."""
        provider = IEEEXploreProvider(api_key="test_key")

        with patch("requests.get") as mock_get:
            mock_get.side_effect = Exception("API error")

            results = provider.search("test")
            assert results == []

    def test_handles_missing_fields(self):
        """search() handles articles with missing optional fields."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{"title": "Minimal Paper"}]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert len(results) == 1
            paper = results[0]
            assert paper.title == "Minimal Paper"
            assert paper.authors == []
            assert paper.year is None
            assert paper.doi is None
            assert paper.abstract is None

    def test_caps_limit_at_200(self):
        """search() caps limit at IEEE's maximum of 200."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test", limit=500)

            call_args = mock_get.call_args
            assert call_args[1]["params"]["max_records"] == 200

    def test_sends_api_key_as_parameter(self):
        """search() sends API key as query parameter."""
        provider = IEEEXploreProvider(api_key="my_ieee_key")

        mock_response = Mock()
        mock_response.json.return_value = {"articles": []}
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            provider.search("test")

            call_args = mock_get.call_args
            assert call_args[1]["params"]["apikey"] == "my_ieee_key"

    def test_uses_abstract_url_as_fallback(self):
        """search() uses abstract_url when html_url is not available."""
        provider = IEEEXploreProvider(api_key="test_key")

        mock_response = Mock()
        mock_response.json.return_value = {
            "articles": [{
                "title": "Paper",
                "abstract_url": "https://ieeexplore.ieee.org/abstract/1234",
            }]
        }
        mock_response.raise_for_status = Mock()

        with patch("requests.get") as mock_get:
            mock_get.return_value = mock_response

            results = provider.search("test")

            assert results[0].url == "https://ieeexplore.ieee.org/abstract/1234"


class TestIEEEXploreIntegration:
    """Integration test for the IEEE Xplore provider."""

    @pytest.mark.integration
    @pytest.mark.skip(reason="Skipped by default; requires IEEE_API_KEY")
    def test_real_api_call(self):
        """Make one real API call to verify the provider works."""
        import os

        api_key = os.environ.get("IEEE_API_KEY")
        if not api_key:
            pytest.skip("IEEE_API_KEY environment variable not set")

        provider = IEEEXploreProvider(api_key=api_key)

        try:
            papers = provider.search("machine learning", limit=1)

            assert len(papers) >= 1, "Provider returned no results"

            paper = papers[0]
            assert isinstance(paper, Paper)
            assert paper.title
            assert paper.source == "ieee"
        except Exception as e:
            pytest.skip(f"IEEE Xplore API unavailable: {e}")
@


\section{Dependencies}

We organize imports so each provider's dependencies are co-located with
its implementation.
If a provider is removed, its dependencies go with it.

<<imports>>=
import logging
import os
from typing import Protocol

from cachetools import cachedmethod

from scholar import Paper
from scholar.cache import load_cache, register_cache
<<semantic scholar imports>>
<<openalex imports>>
<<dblp imports>>

logger = logging.getLogger(__name__)
@

<<constants>>=
# Provider constants
DEFAULT_LIMIT = 100
<<dblp constants>>
<<wos constants>>
<<ieee constants>>
@
