\chapter{Command-Line Interface}
\label{cli-module}

\section{Introduction}

This document describes the command-line interface for Scholar.
While the core library (\texttt{scholar.py}) provides the data model and search
functionality, users need a convenient way to invoke searches from the terminal.

The CLI serves several purposes:
\begin{description}
\item[Direct invocation] Users can run searches without writing Python code.
\item[Scripting] The CLI supports output formats suitable for shell pipelines.
\item[Extensibility] The subcommand structure allows adding new functionality
  (like snowball searching) without modifying the core interface.
\end{description}


\section{Design decisions}

We use Typer for the CLI framework because it provides:
\begin{itemize}
\item Automatic help generation from type annotations
\item Subcommand support for modular organization
\item Integration with Rich for formatted output
\end{itemize}

The CLI is organized as subcommands to prepare for future extensions.
Currently, we have the [[search]] command; later we will add [[snowball]] and
[[tuxedo]] as git submodules that register their own commands.


\section{Module structure}

The CLI module provides the main entry point:

<<[[cli.py]]>>=
"""
Scholar command-line interface.

Provides commands for structured literature searches
across bibliographic databases.
"""

<<cli imports>>
<<constants>>
<<output formatters>>
<<typer application>>
<<completion functions>>
<<search command>>
<<providers command>>
<<cache command>>
<<pdf command>>
<<notes command>>
<<sessions command>>
<<submodule registration>>
<<main entry point>>
@

We also provide a [[__main__.py]] module so users can run Scholar with
[[python -m scholar]]:

<<[[__main__.py]]>>=
"""Allow running Scholar as a module: python -m scholar"""
from scholar.cli import main

if __name__ == "__main__":
    main()
@


\section{Testing}
\label{ch:cli-testing}

Tests are distributed throughout this document, appearing after each
implementation section they verify.
The test file collects all distributed test chunks:

<<test [[cli.py]]>>=
"""Tests for the CLI module."""
import pytest
from unittest.mock import Mock
from typer.testing import CliRunner

from scholar.cli import *
from scholar import *


<<test functions>>
@


\section{The Typer Application}

We create a Typer application that serves as the root for all subcommands.
The [[no_args_is_help=True]] setting ensures users see help when they run
[[scholar]] without arguments.

To ensure proper subcommand behavior (where users must type [[scholar search]]
rather than just [[scholar]]), we add a callback to the main app.
Without this callback, Typer treats a single command as the default and
absorbs its arguments into the main app.

<<typer application>>=
app = typer.Typer(
    name="scholar",
    help="Structured literature search tool for systematic reviews.",
    no_args_is_help=True,
)


@app.callback()
def callback() -> None:
    """
    Scholar: A tool for structured literature searches.

    Use 'scholar search' to query bibliographic databases.
    """
    pass
@


\section{The Search Command}

The primary command is [[search]], which queries bibliographic databases and
displays results.
We use Typer's [[Annotated]] syntax for clean argument definitions.

<<search command>>=
@app.command()
def search(
    query: Annotated[str, typer.Argument(help="Search query string")],
    <<search command options>>
) -> None:
    """
    Search bibliographic databases with structured queries.

    Queries default providers (openalex, dblp) when no -p option is given.
    Use -p to select specific providers, including those requiring API keys.

    Examples:
        scholar search "machine learning privacy"
        scholar search "federated learning" -p semantic_scholar -f json
        scholar search "neural networks" -p openalex -p dblp -p semantic_scholar
    """
    <<execute search and display results>>
@

\subsection{Shell completion}

To improve the user experience, we provide shell completion for various
options and arguments.
Typer supports this via the [[autocompletion]] parameter, which accepts a
callback function that receives the incomplete text and returns valid
completions.

\paragraph{Provider completion}
For the [[-p]]/[[--provider]] option, we complete from the registered
providers:

<<completion functions>>=
def complete_provider(incomplete: str) -> list[str]:
    """Provide shell completion for provider names."""
    from scholar.providers import PROVIDERS
    return [name for name in PROVIDERS.keys() if name.startswith(incomplete)]
@

\paragraph{Output format completion}
Several commands accept a [[--format]] option.
We define completers for each set of valid formats:

<<completion functions>>=
SEARCH_FORMATS = ["auto", "table", "csv", "json", "bibtex"]
DISPLAY_FORMATS = ["table", "json"]
EXPORT_FORMATS = ["csv", "latex", "all"]


def complete_search_format(incomplete: str) -> list[str]:
    """Provide shell completion for search output formats."""
    return [f for f in SEARCH_FORMATS if f.startswith(incomplete)]


def complete_display_format(incomplete: str) -> list[str]:
    """Provide shell completion for display formats (table/json)."""
    return [f for f in DISPLAY_FORMATS if f.startswith(incomplete)]


def complete_export_format(incomplete: str) -> list[str]:
    """Provide shell completion for export formats."""
    return [f for f in EXPORT_FORMATS if f.startswith(incomplete)]
@

\paragraph{Action completion}
The [[cache]] and [[pdf]] commands take an action argument.
We complete from the valid action names:

<<completion functions>>=
CACHE_ACTIONS = ["clear", "info", "path"]
PDF_ACTIONS = ["open", "info", "clear", "path"]


def complete_cache_action(incomplete: str) -> list[str]:
    """Provide shell completion for cache actions."""
    return [a for a in CACHE_ACTIONS if a.startswith(incomplete)]


def complete_pdf_action(incomplete: str) -> list[str]:
    """Provide shell completion for PDF actions."""
    return [a for a in PDF_ACTIONS if a.startswith(incomplete)]
@

\paragraph{Session name completion}
For commands that operate on saved sessions, we complete from the stored
session names.
This requires dynamically loading the session list:

<<completion functions>>=
def complete_session_name(incomplete: str) -> list[str]:
    """Provide shell completion for session names."""
    from scholar.review import list_sessions
    try:
        sessions = list_sessions()
        return [s["name"] for s in sessions if s["name"].startswith(incomplete)]
    except Exception:
        return []
@

\paragraph{Paper ID completion}
For commands that reference papers with notes, we complete from stored
paper IDs:

<<completion functions>>=
def complete_paper_id(incomplete: str) -> list[str]:
    """Provide shell completion for paper IDs with notes."""
    from scholar.notes import list_papers_with_notes
    try:
        notes = list_papers_with_notes()
        return [n.paper_id for n in notes if n.paper_id.startswith(incomplete)]
    except Exception:
        return []
@

\subsection{Command options}

The search command accepts options for controlling which providers to query
and how to format output:

<<search command options>>=
provider: Annotated[
    Optional[list[str]],
    typer.Option(
        "--provider", "-p",
        help="Provider to query. Repeatable. Default: openalex, dblp.",
        autocompletion=complete_provider,
    ),
] = None,
output_format: Annotated[
    str,
    typer.Option(
        "--format", "-f",
        help="Output format: auto, table, csv, json, or bibtex. "
             "Auto selects table for TTY, csv otherwise.",
        autocompletion=complete_search_format,
    ),
] = "auto",
review: Annotated[
    bool,
    typer.Option(
        "--review", "-r",
        help="Launch interactive TUI to review and filter results.",
    ),
] = False,
name: Annotated[
    Optional[str],
    typer.Option(
        "--name", "-n",
        help="Session name for review. Use same name to append results from "
             "multiple searches. Defaults to query string.",
    ),
] = None
@

\subsection{Executing the search}

We import the [[Search]] class from the core module and execute the query.
The results are then passed to the appropriate formatter:

<<execute search and display results>>=
from scholar import Search
import sys

s = Search(query)
results = s.execute(providers=provider)

# If review mode, launch TUI instead of displaying results
if review:
    from scholar.tui import run_review
    session_name = name if name else query
    run_review(results, query, session_name)
    return

# Auto-detect format based on TTY
actual_format = output_format
if output_format == "auto":
    actual_format = "table" if sys.stdout.isatty() else "csv"

display_results(results, actual_format)
@


\section{Listing Available Providers}

Users need to know which search providers are available and how to configure
them.
Rather than requiring users to read the literate documentation, we provide a
[[providers]] command that displays this information directly.

<<providers command>>=
@app.command()
def providers() -> None:
    """
    List available search providers and their configuration.

    Shows which providers require API keys and how to obtain them.
    """
    <<display provider information>>
@

We organize provider information in a table showing the provider name,
whether it is a default, whether an API key is required, and the environment
variable to set:

<<display provider information>>=
from scholar.providers import get_all_providers, DEFAULT_PROVIDERS

console = Console()

table = Table(title="Available Search Providers", box=box.HORIZONTALS)
table.add_column("Provider", style="cyan")
table.add_column("Default", style="magenta")
table.add_column("API Key", style="yellow")
table.add_column("Environment Variable", style="green")
table.add_column("How to Get Key", style="dim")

<<add provider rows to table>>

console.print(table)
console.print()
console.print("[dim]Default providers are used when no -p option is given.[/dim]")
console.print("[dim]Use -p <name> to add non-default providers to a search.[/dim]")
@

We define the configuration details for each provider.
This information is kept here rather than in the provider classes because
it is user-facing documentation, not implementation details:

<<add provider rows to table>>=
provider_info = {
    "semantic_scholar": {
        "required": False,
        "env_var": "S2_API_KEY",
        "how_to_get": "api.semanticscholar.org (optional, higher rate limits)",
    },
    "openalex": {
        "required": False,
        "env_var": "OPENALEX_EMAIL",
        "how_to_get": "Any email (optional, faster responses)",
    },
    "dblp": {
        "required": False,
        "env_var": "-",
        "how_to_get": "No key needed",
    },
    "wos": {
        "required": True,
        "env_var": "WOS_API_KEY",
        "how_to_get": "developer.clarivate.com",
    },
    "ieee": {
        "required": True,
        "env_var": "IEEE_API_KEY",
        "how_to_get": "developer.ieee.org",
    },
}

for provider in get_all_providers():
    info = provider_info.get(provider.name, {})
    is_default = provider.name in DEFAULT_PROVIDERS
    default_status = "[green]Yes[/green]" if is_default else "[dim]No[/dim]"
    required = info.get("required", False)
    key_status = "[red]Required[/red]" if required else "[green]Optional[/green]"
    table.add_row(
        provider.name,
        default_status,
        key_status,
        info.get("env_var", "-"),
        info.get("how_to_get", ""),
    )
@


\section{Cache Management}
\label{ch:cache-cli}

Search results are cached to avoid redundant API calls.
Users can inspect and manage the cache using the [[cache]] command.

\subsection{Action-Based Design}

We use an action argument ([[clear]], [[info]], [[path]]) rather than
subcommands for cache management. This keeps the interface simpler for
a small set of related operations:
\begin{description}
\item[clear] Delete all cached results---useful when API data has changed
\item[info] Show statistics---helpful for debugging or quota planning
\item[path] Print directory---for scripting or manual inspection
\end{description}

If cache management grew more complex (e.g., per-provider clearing,
expiration policies), we might refactor to subcommands like the [[notes]]
command uses.

<<cache command>>=
@app.command()
def cache(
    action: Annotated[
        str,
        typer.Argument(
            help="Action: clear, info, or path",
            autocompletion=complete_cache_action,
        ),
    ],
) -> None:
    """
    Manage the search result cache.

    Actions:
        clear  - Delete all cached search results
        info   - Show cache statistics (entries, size, location)
        path   - Print the cache directory path
    """
    from scholar.cache import clear_cache, get_cache_stats

    console = Console()

    if action == "clear":
        count = clear_cache()
        console.print(f"Cleared {count} cached provider(s).")

    elif action == "info":
        stats = get_cache_stats()
        table = Table(title="Cache Statistics", box=box.HORIZONTALS)
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")

        table.add_row("Location", stats["cache_dir"])
        table.add_row("Total entries", str(stats["total_entries"]))
        size_kb = stats["total_size_bytes"] / 1024
        table.add_row("Total size", f"{size_kb:.1f} KB")

        console.print(table)

        if stats["providers"]:
            console.print()
            provider_table = Table(title="Entries per Provider", box=box.HORIZONTALS)
            provider_table.add_column("Provider", style="cyan")
            provider_table.add_column("Cached queries", justify="right")

            for provider_name, count in sorted(stats["providers"].items()):
                provider_table.add_row(provider_name, str(count))

            console.print(provider_table)

    elif action == "path":
        stats = get_cache_stats()
        print(stats["cache_dir"])

    else:
        console.print(f"[red]Unknown action: {action}[/red]")
        console.print("Valid actions: clear, info, path")
        raise typer.Exit(1)
@


\section{PDF Management}
\label{ch:pdf-cli}

Researchers often need to download and view PDFs when reviewing papers.
The [[pdf]] command provides access to PDF download, caching, and viewing
functionality.

\subsection{Command Design}

Like the [[cache]] command, [[pdf]] uses an action argument with an optional
URL parameter:
\begin{description}
\item[pdf open <url>] Download (if needed) and open a PDF from its URL
\item[pdf info] Show PDF cache statistics
\item[pdf clear] Delete all cached PDFs
\item[pdf path] Print the PDF cache directory path
\end{description}

The [[open]] action is the primary use case---it handles the full workflow
of checking the cache, downloading if necessary, and opening in the system
viewer.

<<pdf command>>=
@app.command()
def pdf(
    action: Annotated[
        str,
        typer.Argument(
            help="Action: open, info, clear, or path",
            autocompletion=complete_pdf_action,
        ),
    ],
    url: Annotated[
        Optional[str],
        typer.Argument(help="PDF URL (required for 'open' action)"),
    ] = None,
) -> None:
    """
    Manage PDF downloads and cache.

    Actions:
        open <url>  - Download (if needed) and open a PDF
        info        - Show PDF cache statistics
        clear       - Delete all cached PDFs
        path        - Print the PDF cache directory path
    
    Examples:
        scholar pdf open "https://arxiv.org/pdf/2301.00001.pdf"
        scholar pdf info
        scholar pdf clear
    """
    from scholar.pdf import (
        get_pdf_cache_dir, get_pdf, open_pdf, 
        clear_pdf_cache, get_pdf_cache_info, PDFDownloadError
    )

    console = Console()

    if action == "open":
        if not url:
            console.print("[red]Error: URL required for 'open' action[/red]")
            console.print("Usage: scholar pdf open <url>")
            raise typer.Exit(1)
        
        try:
            console.print(f"[dim]Fetching PDF...[/dim]")
            pdf_path = get_pdf(url)
            console.print(f"[green]PDF cached at: {pdf_path}[/green]")
            
            if open_pdf(pdf_path):
                console.print("[dim]Opened in system viewer[/dim]")
            else:
                console.print("[yellow]Could not open PDF viewer[/yellow]")
                console.print(f"[dim]PDF available at: {pdf_path}[/dim]")
        except PDFDownloadError as e:
            console.print(f"[red]Download failed: {e}[/red]")
            raise typer.Exit(1)

    elif action == "info":
        info = get_pdf_cache_info()
        table = Table(title="PDF Cache Statistics", box=box.HORIZONTALS)
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")

        table.add_row("Location", str(get_pdf_cache_dir()))
        table.add_row("Cached PDFs", str(info["count"]))
        size_mb = info["size_bytes"] / (1024 * 1024)
        table.add_row("Total size", f"{size_mb:.1f} MB")

        console.print(table)

    elif action == "clear":
        count = clear_pdf_cache()
        console.print(f"[green]Cleared {count} cached PDF(s).[/green]")

    elif action == "path":
        print(get_pdf_cache_dir())

    else:
        console.print(f"[red]Unknown action: {action}[/red]")
        console.print("Valid actions: open, info, clear, path")
        raise typer.Exit(1)
@


\section{Notes Management}
\label{ch:notes-cli}

Paper notes are stored persistently and can be browsed, exported, and imported.
The [[notes]] command provides access to these features.

\subsection{Subcommand Hierarchy}

Unlike the [[cache]] command which uses a single action argument, [[notes]]
uses Typer subcommands because it has more operations with different
argument patterns:
\begin{description}
\item[notes] (no subcommand) Launch TUI for browsing papers with notes
\item[notes list] List papers with notes (table or JSON output)
\item[notes show] Display a specific paper's notes
\item[notes export] Save all notes to a JSON file for backup or sharing
\item[notes import] Load notes from a JSON file, merging with existing
\item[notes clear] Delete all notes (with confirmation)
\end{description}

The subcommand structure scales better and allows each operation to have
its own arguments and help text.

\subsection{Default Behavior}

When invoked without a subcommand, [[scholar notes]] launches a TUI for
browsing all papers that have notes attached. This uses Typer's
[[invoke_without_command=True]] callback pattern.

<<notes command>>=
notes_app = typer.Typer(
    name="notes",
    help="Manage paper notes and annotations.",
    no_args_is_help=False,
)
app.add_typer(notes_app, name="notes")


@notes_app.callback(invoke_without_command=True)
def notes_callback(ctx: typer.Context) -> None:
    """
    Browse and manage paper notes.

    When invoked without a subcommand, launches an interactive TUI
    for browsing all papers with notes.
    """
    if ctx.invoked_subcommand is None:
        from scholar.tui import run_notes_browser
        run_notes_browser()


@notes_app.command("list")
def notes_list(
    output_format: Annotated[
        str,
        typer.Option(
            "--format", "-f",
            help="Output format: table or json.",
            autocompletion=complete_display_format,
        ),
    ] = "table",
) -> None:
    """
    List all papers with notes.

    Shows paper titles, note excerpts, and timestamps.
    """
    from scholar.notes import list_papers_with_notes

    console = Console()
    notes = list_papers_with_notes()

    if not notes:
        console.print("[dim]No papers have notes yet.[/dim]")
        return

    if output_format == "json":
        import json
        output = [
            {
                "paper_id": n.paper_id,
                "title": n.title,
                "note": n.note,
                "created_at": n.created_at.isoformat(),
                "updated_at": n.updated_at.isoformat(),
            }
            for n in notes
        ]
        print(json.dumps(output, indent=2))
    else:
        table = Table(title="Papers with Notes", box=box.HORIZONTALS)
        table.add_column("Title", style="cyan", no_wrap=False, max_width=50)
        table.add_column("Note Preview", style="dim", max_width=30)
        table.add_column("Updated", style="green")

        for note in notes:
            preview = note.note[:50] + "..." if len(note.note) > 50 else note.note
            preview = preview.replace("\n", " ")
            table.add_row(
                note.title[:50] + ("..." if len(note.title) > 50 else ""),
                preview,
                note.updated_at.strftime("%Y-%m-%d"),
            )

        console.print(table)
        console.print(f"\n[dim]Total: {len(notes)} paper(s) with notes[/dim]")


@notes_app.command("show")
def notes_show(
    paper_id: Annotated[
        str,
        typer.Argument(
            help="Paper ID (DOI or hash) to show notes for.",
            autocompletion=complete_paper_id,
        ),
    ],
) -> None:
    """
    Show notes for a specific paper.

    Use 'scholar notes list' to find paper IDs.
    """
    from scholar.notes import list_papers_with_notes

    console = Console()
    notes = list_papers_with_notes()

    for note in notes:
        if note.paper_id == paper_id or paper_id in note.paper_id:
            console.print(f"[bold]{note.title}[/bold]")
            console.print(f"[dim]ID: {note.paper_id}[/dim]")
            console.print(f"[dim]Updated: {note.updated_at.strftime('%Y-%m-%d %H:%M')}[/dim]")
            console.print()
            console.print(note.note)
            return

    console.print(f"[red]No notes found for paper ID: {paper_id}[/red]")
    raise typer.Exit(1)


@notes_app.command("export")
def notes_export(
    output: Annotated[
        Path,
        typer.Argument(help="Output file path (JSON format)."),
    ] = Path("scholar_notes.json"),
) -> None:
    """
    Export all notes to a JSON file.

    Creates a backup of all paper notes that can be imported later.
    """
    from scholar.notes import export_notes

    console = Console()
    count = export_notes(output)
    console.print(f"[green]Exported {count} note(s) to {output}[/green]")


@notes_app.command("import")
def notes_import(
    input_file: Annotated[
        Path,
        typer.Argument(help="Input file path (JSON format)."),
    ],
    merge: Annotated[
        bool,
        typer.Option(
            "--merge", "-m",
            help="Merge with existing notes (default: replace).",
        ),
    ] = False,
) -> None:
    """
    Import notes from a JSON file.

    By default, replaces existing notes. Use --merge to combine.
    """
    from scholar.notes import import_notes

    console = Console()

    if not input_file.exists():
        console.print(f"[red]File not found: {input_file}[/red]")
        raise typer.Exit(1)

    count = import_notes(input_file, merge=merge)
    action = "Merged" if merge else "Imported"
    console.print(f"[green]{action} {count} note(s) from {input_file}[/green]")


@notes_app.command("clear")
def notes_clear(
    force: Annotated[
        bool,
        typer.Option(
            "--force", "-f",
            help="Skip confirmation prompt.",
        ),
    ] = False,
) -> None:
    """
    Delete all notes.

    Requires --force flag to confirm deletion.
    """
    from scholar.notes import list_papers_with_notes, get_data_dir
    import shutil

    console = Console()
    notes = list_papers_with_notes()

    if not notes:
        console.print("[dim]No notes to clear.[/dim]")
        return

    if not force:
        console.print(f"[yellow]This will delete {len(notes)} note(s).[/yellow]")
        console.print("[yellow]Use --force to confirm.[/yellow]")
        raise typer.Exit(1)

    # Delete the notes file
    notes_file = get_data_dir() / "paper_notes.json"
    if notes_file.exists():
        notes_file.unlink()

    console.print(f"[green]Deleted {len(notes)} note(s).[/green]")
@


\section{Session Management}
\label{ch:session-management}

The [[sessions]] command provides access to saved review sessions without
launching the full TUI. Users can:
\begin{description}
\item[sessions list] View all saved review sessions with their statistics
\item[sessions show] Display details of a specific session
\item[sessions export] Generate reports (CSV, \LaTeX{}) from a saved session
\item[sessions resume] Continue reviewing a saved session in the TUI
\end{description}

This enables scripted workflows and integration with other tools.

\subsection{The sessions command group}

<<sessions command>>=
sessions_app = typer.Typer(
    name="sessions",
    help="Manage saved review sessions.",
    no_args_is_help=True,
)
app.add_typer(sessions_app, name="sessions")


@sessions_app.command("list")
def sessions_list(
    output_format: Annotated[
        str,
        typer.Option(
            "--format", "-f",
            help="Output format: table or json.",
            autocompletion=complete_display_format,
        ),
    ] = "table",
) -> None:
    """
    List all saved review sessions.

    Shows query, providers, timestamps, and paper counts.
    """
    from scholar.review import list_sessions

    console = Console()
    sessions = list_sessions()

    if not sessions:
        console.print("[dim]No saved sessions found.[/dim]")
        return

    if output_format == "json":
        print(json.dumps(sessions, indent=2, default=str))
    else:
        table = Table(title="Saved Review Sessions", box=box.HORIZONTALS)
        table.add_column("Name", style="cyan", no_wrap=False)
        table.add_column("Date", style="dim")
        table.add_column("Kept", style="green", justify="right")
        table.add_column("Discarded", style="red", justify="right")
        table.add_column("Pending", style="yellow", justify="right")

        for s in sessions:
            table.add_row(
                s["name"],
                s["timestamp"].strftime("%Y-%m-%d %H:%M"),
                str(s["kept"]),
                str(s["discarded"]),
                str(s["pending"]),
            )

        console.print(table)
        console.print(f"\n[dim]Total: {len(sessions)} session(s)[/dim]")


@sessions_app.command("show")
def sessions_show(
    name: Annotated[
        str,
        typer.Argument(
            help="Session name or query to show.",
            autocompletion=complete_session_name,
        ),
    ],
    output_format: Annotated[
        str,
        typer.Option(
            "--format", "-f",
            help="Output format: table or json.",
            autocompletion=complete_display_format,
        ),
    ] = "table",
) -> None:
    """
    Show details of a saved review session.

    Displays all papers with their decisions, themes, and motivations.
    Uses a pager for interactive viewing when output is a terminal.
    """
    import sys
    from rich.pager import Pager
    from scholar.review import load_session

    console = Console()
    session = load_session(name)

    if session is None:
        console.print(f"[red]Session not found: {name}[/red]")
        raise typer.Exit(1)

    if output_format == "json":
        output = {
            "query": session.query,
            "providers": session.providers,
            "timestamp": session.timestamp.isoformat(),
            "decisions": [
                {
                    "title": d.paper.title,
                    "authors": d.paper.authors,
                    "year": d.paper.year,
                    "status": d.status.value,
                    "tags": d.tags,
                    "provider": d.provider,
                }
                for d in session.decisions
            ],
        }
        print(json.dumps(output, indent=2))
    else:
        # Build rich output, use pager if TTY
        from io import StringIO
        from rich.console import Console as RichConsole
        
        # Render to string first to check if pager needed
        string_io = StringIO()
        render_console = RichConsole(file=string_io, force_terminal=True)
        
        render_console.print(f"[bold]Session: {session.query}[/bold]")
        render_console.print(f"[dim]Date: {session.timestamp.strftime('%Y-%m-%d %H:%M')}[/dim]")
        render_console.print(f"[dim]Providers: {', '.join(session.providers)}[/dim]")
        render_console.print()

        # Show kept papers
        kept = session.kept_papers
        if kept:
            render_console.print(f"[green bold]Kept ({len(kept)}):[/green bold]")
            for d in kept:
                tags = f" [dim]\\[{', '.join(d.tags)}][/dim]" if d.tags else ""
                render_console.print(f"  • {d.paper.title}{tags}")
            render_console.print()

        # Show discarded papers
        discarded = session.discarded_papers
        if discarded:
            render_console.print(f"[red bold]Discarded ({len(discarded)}):[/red bold]")
            for d in discarded:
                tags = f" [dim]\\[{', '.join(d.tags)}][/dim]" if d.tags else ""
                render_console.print(f"  • {d.paper.title}{tags}")
            render_console.print()

        # Show pending papers
        pending = session.pending_papers
        if pending:
            render_console.print(f"[yellow bold]Pending ({len(pending)}):[/yellow bold]")
            for d in pending:
                render_console.print(f"  • {d.paper.title}")
        
        output_text = string_io.getvalue()
        
        # Use pager if TTY, otherwise just print
        if sys.stdout.isatty():
            with console.pager(styles=True):
                console.print(output_text, end="")
        else:
            print(output_text, end="")


@sessions_app.command("export")
def sessions_export(
    name: Annotated[
        str,
        typer.Argument(
            help="Session name or query to export.",
            autocompletion=complete_session_name,
        ),
    ],
    output: Annotated[
        Optional[str],
        typer.Option(
            "--output", "-o",
            help="Output base filename (without extension). Defaults to session name.",
        ),
    ] = None,
    format_type: Annotated[
        str,
        typer.Option(
            "--format", "-f",
            help="Export format: csv, latex, or all.",
            autocompletion=complete_export_format,
        ),
    ] = "all",
) -> None:
    """
    Export a saved session to file(s).

    Generates CSV and/or LaTeX reports from a saved review session.
    Use --format to select specific formats.
    """
    from scholar.review import (
        load_session, generate_latex_report, generate_csv_report,
    )

    console = Console()
    session = load_session(name)

    if session is None:
        console.print(f"[red]Session not found: {name}[/red]")
        raise typer.Exit(1)

    # Use session query as default output name (sanitized)
    if output is None:
        # Sanitize query for filename
        safe_name = "".join(
            c if c.isalnum() or c in "-_" else "_"
            for c in session.query[:30]
        )
        output = f"review_{safe_name}"

    files_created = []

    if format_type in ("csv", "all"):
        csv_path = Path(f"{output}.csv")
        generate_csv_report(session, csv_path)
        files_created.append(csv_path)

    if format_type in ("latex", "all"):
        tex_path = Path(f"{output}.tex")
        generate_latex_report(session, tex_path)
        files_created.append(tex_path)
        files_created.append(tex_path.with_suffix(".bib"))

    console.print("[green]Exported:[/green]")
    for f in files_created:
        console.print(f"  - {f}")


@sessions_app.command("resume")
def sessions_resume(
    name: Annotated[
        str,
        typer.Argument(
            help="Session name or query to resume.",
            autocompletion=complete_session_name,
        ),
    ],
) -> None:
    """
    Resume reviewing a saved session in the TUI.

    Opens the interactive review interface with the saved session loaded.
    """
    from scholar.review import load_session, save_session
    from scholar.tui import PaperReviewApp, prompt_for_report

    console = Console()
    session = load_session(name)

    if session is None:
        console.print(f"[red]Session not found: {name}[/red]")
        raise typer.Exit(1)

    console.print(f"[dim]Resuming session: {session.query}[/dim]")

    app = PaperReviewApp(session)
    app.run()

    # Save updated session
    save_session(session)

    prompt_for_report(session)
@


\section{Output Formatting}
\label{ch:output-formatting}

Different use cases require different output formats:
\begin{description}
\item[table] Human-readable Rich tables for interactive use.
\item[csv] Comma-separated values for spreadsheets and data processing.
\item[json] Machine-readable format for scripting and pipelines.
\item[bibtex] Citation format for integration with \LaTeX{} documents.
\end{description}

\subsection{Automatic Format Detection}

The [[auto]] format (the default) detects whether output goes to a terminal
or a pipe, selecting the appropriate format:
\begin{itemize}
\item Terminal (TTY): Use [[table]] for human readability
\item Pipe/file: Use [[csv]] for machine processing
\end{itemize}

This UX pattern means [[scholar search "query"]] shows pretty tables for
humans, while [[scholar search "query" | wc -l]] counts lines correctly.

\subsection{Formatter Architecture}

We implement a formatter for each and dispatch based on the user's choice.

\subsection{The display function}

This function selects the appropriate formatter and invokes it:

<<output formatters>>=
<<formatter classes>>

FORMATTERS: dict[str, type] = {
    "table": TableFormatter,
    "csv": CSVFormatter,
    "json": JSONFormatter,
    "bibtex": BibTeXFormatter,
}


def display_results(results: list, output_format: str = "table") -> None:
    """
    Display search results in the specified format.

    Args:
        results: List of SearchResult objects to display.
        output_format: One of 'table', 'csv', 'json', or 'bibtex'.
    """
    formatter_class = FORMATTERS.get(output_format, TableFormatter)
    formatter = formatter_class()
    formatter.format(results)
@


\subsection{Table formatter}

The table formatter uses Rich to create visually appealing output.
We show the query and provider as context, then list papers with key metadata:

<<formatter classes>>=
class TableFormatter:
    """Display results as Rich tables."""

    def __init__(self) -> None:
        self.console = Console()

    def format(self, results: list) -> None:
        """Display results in formatted tables."""
        for result in results:
            table = Table(
                title=f"Results for: {result.query}",
                caption=f"Provider: {result.provider} | {result.timestamp}",
                box=box.HORIZONTALS,
            )

            table.add_column("Title", style="cyan", no_wrap=False)
            table.add_column("Authors", style="green")
            table.add_column("Year", justify="right")
            table.add_column("DOI", style="dim")

            for paper in result.papers:
                authors = ", ".join(paper.authors[:3])
                if len(paper.authors) > 3:
                    authors += "..."
                table.add_row(
                    paper.title,
                    authors,
                    str(paper.year) if paper.year else "",
                    paper.doi or "",
                    end_section=True,
                )

            self.console.print(table)

            if not result.papers:
                self.console.print("[dim]No results found.[/dim]")
@


\subsection{CSV formatter}

For scripting and shell pipelines, we provide a tab-separated CSV format.
This is especially useful when output is piped to other commands.
We include metadata as a comment header so consumers know the search context:

<<formatter classes>>=
class CSVFormatter:
    """Output results as tab-separated values for scripting."""

    def format(self, results: list) -> None:
        """Output results as CSV with metadata header."""
        for result in results:
            # Metadata header as comments
            print(f"# Query: {result.query}")
            print(f"# Provider: {result.provider}")
            print(f"# Timestamp: {result.timestamp}")
            print(f"# Results: {len(result.papers)}")
            print()

            # Header row
            print("title\tauthors\tyear\tdoi\tvenue\turl")

            # Data rows
            for paper in result.papers:
                authors = "; ".join(paper.authors)
                year = str(paper.year) if paper.year else ""
                print(f"{paper.title}\t{authors}\t{year}\t"
                      f"{paper.doi or ''}\t{paper.venue or ''}\t"
                      f"{paper.url or ''}")
            print()
@


\subsection{JSON formatter}

For scripting, we provide JSON output that includes all paper metadata:

<<formatter classes>>=
class JSONFormatter:
    """Output results as JSON for scripting."""

    def format(self, results: list) -> None:
        """Output results as JSON."""
        output = []
        for result in results:
            output.append({
                "query": result.query,
                "provider": result.provider,
                "timestamp": result.timestamp,
                "papers": [
                    {
                        "title": p.title,
                        "authors": p.authors,
                        "year": p.year,
                        "doi": p.doi,
                        "abstract": p.abstract,
                        "venue": p.venue,
                        "url": p.url,
                    }
                    for p in result.papers
                ],
            })
        print(json.dumps(output, indent=2))
@


\subsection{BibTeX formatter}

For \LaTeX{} users, we generate BibTeX entries that can be added to a
[[.bib]] file:

<<formatter classes>>=
class BibTeXFormatter:
    """Output results as BibTeX entries."""

    def format(self, results: list) -> None:
        """Output results as BibTeX."""
        for result in results:
            for paper in result.papers:
                self._format_paper(paper)

    def _format_paper(self, paper) -> None:
        """Format a single paper as BibTeX."""
        first_author = (
            paper.authors[0].split()[-1] if paper.authors else "unknown"
        )
        year = paper.year or "nd"
        key = f"{first_author.lower()}{year}"

        print(f"@article{{{key},")
        print(f"  title = {{{paper.title}}},")
        print(f"  author = {{{' and '.join(paper.authors)}}},")
        if paper.year:
            print(f"  year = {{{paper.year}}},")
        if paper.doi:
            print(f"  doi = {{{paper.doi}}},")
        if paper.venue:
            print(f"  journal = {{{paper.venue}}},")
        print("}")
        print()
@

\subsection{Testing formatters}

We test each formatter with sample data:

<<test functions>>=
class TestFormatters:
    """Tests for output formatters."""

    @pytest.fixture
    def sample_results(self):
        """Create sample search results for testing."""
        papers = [
            Paper(
                title="Test Paper",
                authors=["Alice", "Bob"],
                year=2024,
                doi="10.1234/test",
            ),
        ]
        return [
            SearchResult(
                query="test",
                provider="test_provider",
                timestamp="2024-01-01T00:00:00",
                papers=papers,
            )
        ]

    def test_table_formatter(self, sample_results, capsys):
        """TableFormatter produces output."""
        formatter = TableFormatter()
        formatter.format(sample_results)
        captured = capsys.readouterr()
        assert "Test Paper" in captured.out

    def test_json_formatter(self, sample_results, capsys):
        """JSONFormatter produces valid JSON."""
        formatter = JSONFormatter()
        formatter.format(sample_results)
        captured = capsys.readouterr()
        import json
        data = json.loads(captured.out)
        assert data[0]["query"] == "test"
        assert data[0]["papers"][0]["title"] == "Test Paper"

    def test_bibtex_formatter(self, sample_results, capsys):
        """BibTeXFormatter produces BibTeX entries."""
        formatter = BibTeXFormatter()
        formatter.format(sample_results)
        captured = capsys.readouterr()
        assert "@article{" in captured.out
        assert "title = {Test Paper}" in captured.out
@


\section{Submodule Registration}

To support future extensions like snowball and tuxedo, we provide a mechanism
for submodules to register their commands with the main application.

Each submodule should provide a [[register_commands(app)]] function that adds
its commands to the Typer app.
We attempt to import each known submodule and call this function if it exists:

<<submodule registration>>=
SUBMODULES = ["snowball", "tuxedo"]


def register_submodules() -> None:
    """
    Dynamically register subcommand modules if available.

    This allows snowball and tuxedo to be added as git submodules
    without modifying this file. Each submodule should provide a
    `register_commands(app)` function.
    """
    for name in SUBMODULES:
        try:
            module = __import__(f"scholar.{name}", fromlist=["register_commands"])
            if hasattr(module, "register_commands"):
                module.register_commands(app)
        except ImportError:
            pass  # Submodule not installed
@


\section{Entry Point}

The main entry point registers any available submodules and then runs the
Typer application:

<<main entry point>>=
def main() -> None:
    """Main entry point for the Scholar CLI."""
    register_submodules()
    app()
@

\subsection{Testing the CLI application}

We use Typer's [[CliRunner]] to test the CLI without actually invoking
a subprocess:

<<test functions>>=
runner = CliRunner()


class TestCLI:
    """Tests for the CLI application."""

    def test_help_displayed(self):
        """Running without args shows help with 'search' command listed."""
        result = runner.invoke(app, [])
        # Exit code 2 is expected (no command given), but help should show
        assert "search" in result.stdout
        assert "Commands" in result.stdout

    def test_explicit_help(self):
        """Running with --help shows help with exit code 0."""
        result = runner.invoke(app, ["--help"])
        assert result.exit_code == 0
        assert "search" in result.stdout

    def test_search_command_exists(self):
        """The search command is registered."""
        result = runner.invoke(app, ["search", "--help"])
        assert result.exit_code == 0
        assert "Search bibliographic databases" in result.stdout

    def test_search_runs(self, monkeypatch):
        """Search command executes without error."""
        # Mock the provider to avoid real API calls
        from scholar import providers

        mock_provider = Mock()
        mock_provider.name = "mock"
        mock_provider.search.return_value = []
        monkeypatch.setattr(providers, "PROVIDERS", {"mock": mock_provider})

        result = runner.invoke(app, ["search", "test query"])
        assert result.exit_code == 0

    def test_providers_command_exists(self):
        """The providers command is registered."""
        result = runner.invoke(app, ["providers", "--help"])
        assert result.exit_code == 0
        assert "List available search providers" in result.stdout

    def test_providers_lists_providers(self):
        """The providers command lists available providers."""
        result = runner.invoke(app, ["providers"])
        assert result.exit_code == 0
        # Should show at least these providers
        assert "semantic_scholar" in result.stdout
        assert "openalex" in result.stdout
        assert "dblp" in result.stdout

    def test_providers_shows_api_info(self):
        """The providers command shows API key information."""
        result = runner.invoke(app, ["providers"])
        assert result.exit_code == 0
        # Should show environment variable names
        assert "S2_API_KEY" in result.stdout
        assert "WOS_API_KEY" in result.stdout
        assert "IEEE_API_KEY" in result.stdout

    def test_cache_command_exists(self):
        """The cache command is registered."""
        result = runner.invoke(app, ["cache", "--help"])
        assert result.exit_code == 0
        assert "Manage the search result cache" in result.stdout

    def test_cache_info(self, tmp_path, monkeypatch):
        """Cache info shows statistics."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        result = runner.invoke(app, ["cache", "info"])
        assert result.exit_code == 0
        assert "Location" in result.stdout
        assert "Total entries" in result.stdout

    def test_cache_clear(self, tmp_path, monkeypatch):
        """Cache clear removes cache files."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        # Create a dummy cache file
        (tmp_path / "test.pkl").touch()
        result = runner.invoke(app, ["cache", "clear"])
        assert result.exit_code == 0
        assert "Cleared" in result.stdout

    def test_cache_path(self, tmp_path, monkeypatch):
        """Cache path prints directory."""
        monkeypatch.setenv("SCHOLAR_CACHE_DIR", str(tmp_path))
        result = runner.invoke(app, ["cache", "path"])
        assert result.exit_code == 0
        assert str(tmp_path) in result.stdout

    def test_cache_invalid_action(self):
        """Cache with invalid action shows error."""
        result = runner.invoke(app, ["cache", "invalid"])
        assert result.exit_code == 1
        assert "Unknown action" in result.stdout
@


\section{Dependencies}

We collect the imports used throughout the module:

<<cli imports>>=
from typing import Optional
from typing_extensions import Annotated
from pathlib import Path
import json

import typer
from rich import box
from rich.console import Console
from rich.table import Table
@

<<constants>>=
# CLI constants (reserved for future use)
@
